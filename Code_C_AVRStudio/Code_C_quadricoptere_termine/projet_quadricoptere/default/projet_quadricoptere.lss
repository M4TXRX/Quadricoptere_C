
projet_quadricoptere.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000016  00800200  000013a4  00001438  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000013a4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000015c  00800216  00800216  0000144e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000144e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001480  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000228  00000000  00000000  000014c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000044d8  00000000  00000000  000016e8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000017ca  00000000  00000000  00005bc0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000153a  00000000  00000000  0000738a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000514  00000000  00000000  000088c4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000d1b  00000000  00000000  00008dd8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000f9a  00000000  00000000  00009af3  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000188  00000000  00000000  0000aa8d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 94 00 	jmp	0x128	; 0x128 <__ctors_end>
       4:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
       8:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
       c:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      10:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      14:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      18:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      1c:	0c 94 52 05 	jmp	0xaa4	; 0xaa4 <__vector_7>
      20:	0c 94 89 06 	jmp	0xd12	; 0xd12 <__vector_8>
      24:	0c 94 b4 05 	jmp	0xb68	; 0xb68 <__vector_9>
      28:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      2c:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      30:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      34:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      38:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      3c:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      40:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      44:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      48:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      4c:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      50:	0c 94 89 05 	jmp	0xb12	; 0xb12 <__vector_20>
      54:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      58:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      5c:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      60:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      64:	0c 94 5d 04 	jmp	0x8ba	; 0x8ba <__vector_25>
      68:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      6c:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      70:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      74:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      78:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      7c:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      80:	0c 94 a0 05 	jmp	0xb40	; 0xb40 <__vector_32>
      84:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      88:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      8c:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      90:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      94:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      98:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      9c:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      a0:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      a4:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      a8:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      ac:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      b0:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      b4:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      b8:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      bc:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      c0:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      c4:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      c8:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      cc:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      d0:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      d4:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      d8:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      dc:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      e0:	0c 94 b3 00 	jmp	0x166	; 0x166 <__bad_interrupt>
      e4:	7d 04       	cpc	r7, r13
      e6:	7d 04       	cpc	r7, r13
      e8:	7d 04       	cpc	r7, r13
      ea:	7d 04       	cpc	r7, r13
      ec:	a9 04       	cpc	r10, r9
      ee:	89 04       	cpc	r8, r9
      f0:	7d 04       	cpc	r7, r13
      f2:	a9 04       	cpc	r10, r9
      f4:	b3 04       	cpc	r11, r3
      f6:	d4 04       	cpc	r13, r4
      f8:	d4 04       	cpc	r13, r4
      fa:	a9 04       	cpc	r10, r9
      fc:	b3 04       	cpc	r11, r3
      fe:	d4 04       	cpc	r13, r4
     100:	d4 04       	cpc	r13, r4
     102:	a9 04       	cpc	r10, r9
     104:	b3 04       	cpc	r11, r3
     106:	d4 04       	cpc	r13, r4
     108:	d4 04       	cpc	r13, r4
     10a:	a9 04       	cpc	r10, r9
     10c:	89 04       	cpc	r8, r9
     10e:	da 04       	cpc	r13, r10
     110:	a9 04       	cpc	r10, r9
     112:	b3 04       	cpc	r11, r3
     114:	d4 04       	cpc	r13, r4
     116:	d4 04       	cpc	r13, r4
     118:	a9 04       	cpc	r10, r9
     11a:	b3 04       	cpc	r11, r3
     11c:	d4 04       	cpc	r13, r4
     11e:	d4 04       	cpc	r13, r4
     120:	a9 04       	cpc	r10, r9
     122:	b3 04       	cpc	r11, r3
     124:	d4 04       	cpc	r13, r4
     126:	e5 04       	cpc	r14, r5

00000128 <__ctors_end>:
     128:	11 24       	eor	r1, r1
     12a:	1f be       	out	0x3f, r1	; 63
     12c:	cf ef       	ldi	r28, 0xFF	; 255
     12e:	d1 e2       	ldi	r29, 0x21	; 33
     130:	de bf       	out	0x3e, r29	; 62
     132:	cd bf       	out	0x3d, r28	; 61

00000134 <__do_copy_data>:
     134:	12 e0       	ldi	r17, 0x02	; 2
     136:	a0 e0       	ldi	r26, 0x00	; 0
     138:	b2 e0       	ldi	r27, 0x02	; 2
     13a:	e4 ea       	ldi	r30, 0xA4	; 164
     13c:	f3 e1       	ldi	r31, 0x13	; 19
     13e:	00 e0       	ldi	r16, 0x00	; 0
     140:	0b bf       	out	0x3b, r16	; 59
     142:	02 c0       	rjmp	.+4      	; 0x148 <__do_copy_data+0x14>
     144:	07 90       	elpm	r0, Z+
     146:	0d 92       	st	X+, r0
     148:	a6 31       	cpi	r26, 0x16	; 22
     14a:	b1 07       	cpc	r27, r17
     14c:	d9 f7       	brne	.-10     	; 0x144 <__do_copy_data+0x10>

0000014e <__do_clear_bss>:
     14e:	23 e0       	ldi	r18, 0x03	; 3
     150:	a6 e1       	ldi	r26, 0x16	; 22
     152:	b2 e0       	ldi	r27, 0x02	; 2
     154:	01 c0       	rjmp	.+2      	; 0x158 <.do_clear_bss_start>

00000156 <.do_clear_bss_loop>:
     156:	1d 92       	st	X+, r1

00000158 <.do_clear_bss_start>:
     158:	a2 37       	cpi	r26, 0x72	; 114
     15a:	b2 07       	cpc	r27, r18
     15c:	e1 f7       	brne	.-8      	; 0x156 <.do_clear_bss_loop>
     15e:	0e 94 0f 06 	call	0xc1e	; 0xc1e <main>
     162:	0c 94 d0 09 	jmp	0x13a0	; 0x13a0 <_exit>

00000166 <__bad_interrupt>:
     166:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000016a <uart_putchar>:

		for (j=0; j<10; j++){
			_delay_ms(10);
		}
	}
}
     16a:	cf 93       	push	r28
     16c:	c8 2f       	mov	r28, r24
     16e:	8a 30       	cpi	r24, 0x0A	; 10
     170:	19 f4       	brne	.+6      	; 0x178 <uart_putchar+0xe>
     172:	8d e0       	ldi	r24, 0x0D	; 13
     174:	0e 94 b5 00 	call	0x16a	; 0x16a <uart_putchar>
     178:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7e00d0>
     17c:	85 ff       	sbrs	r24, 5
     17e:	fc cf       	rjmp	.-8      	; 0x178 <uart_putchar+0xe>
     180:	c0 93 d6 00 	sts	0x00D6, r28	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7e00d6>
     184:	80 e0       	ldi	r24, 0x00	; 0
     186:	90 e0       	ldi	r25, 0x00	; 0
     188:	cf 91       	pop	r28
     18a:	08 95       	ret

0000018c <uart_getchar>:
     18c:	80 91 d0 00 	lds	r24, 0x00D0	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7e00d0>
     190:	87 ff       	sbrs	r24, 7
     192:	fc cf       	rjmp	.-8      	; 0x18c <uart_getchar>
     194:	80 91 d6 00 	lds	r24, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7e00d6>
     198:	90 e0       	ldi	r25, 0x00	; 0
     19a:	08 95       	ret

0000019c <init_uart>:
     19c:	88 e0       	ldi	r24, 0x08	; 8
     19e:	90 e0       	ldi	r25, 0x00	; 0
     1a0:	90 93 cd 00 	sts	0x00CD, r25	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7e00cd>
     1a4:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7e00cc>
     1a8:	88 e1       	ldi	r24, 0x18	; 24
     1aa:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7e00c9>
     1ae:	86 e0       	ldi	r24, 0x06	; 6
     1b0:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7e00ca>
     1b4:	80 e0       	ldi	r24, 0x00	; 0
     1b6:	92 e0       	ldi	r25, 0x02	; 2
     1b8:	90 93 6f 03 	sts	0x036F, r25	; 0x80036f <__iob+0x3>
     1bc:	80 93 6e 03 	sts	0x036E, r24	; 0x80036e <__iob+0x2>
     1c0:	08 95       	ret

000001c2 <reset_led2>:
     1c2:	e5 e0       	ldi	r30, 0x05	; 5
     1c4:	f1 e0       	ldi	r31, 0x01	; 1
     1c6:	80 81       	ld	r24, Z
     1c8:	8f 7e       	andi	r24, 0xEF	; 239
     1ca:	80 83       	st	Z, r24
     1cc:	08 95       	ret

000001ce <init_port>:
	PORTJ &= (~(1<<LED2));//LED2 OFF
}

void init_port(void){
	//Pour les LEDs :
	DDRJ = DDRJ | (1<<DDJ3) | (1<<DDJ4);
     1ce:	e4 e0       	ldi	r30, 0x04	; 4
     1d0:	f1 e0       	ldi	r31, 0x01	; 1
     1d2:	80 81       	ld	r24, Z
     1d4:	88 61       	ori	r24, 0x18	; 24
     1d6:	80 83       	st	Z, r24

	//Pour les moteurs :
	DDRH |= (1<<DDH3)|(1<<DDH4)|(1<<DDH5);
     1d8:	e1 e0       	ldi	r30, 0x01	; 1
     1da:	f1 e0       	ldi	r31, 0x01	; 1
     1dc:	80 81       	ld	r24, Z
     1de:	88 63       	ori	r24, 0x38	; 56
     1e0:	80 83       	st	Z, r24
	DDRL |= (1<<DDL3)|(1<<DDL4)|(1<<DDL5);
     1e2:	ea e0       	ldi	r30, 0x0A	; 10
     1e4:	f1 e0       	ldi	r31, 0x01	; 1
     1e6:	80 81       	ld	r24, Z
     1e8:	88 63       	ori	r24, 0x38	; 56
     1ea:	80 83       	st	Z, r24

	//Pour l'UART vers l'écran :
	DDRD = DDRD & (~(1<<RXD1)); //En entrée
     1ec:	52 98       	cbi	0x0a, 2	; 10
	DDRD = DDRD | (1<<TXD1); //En sortie
     1ee:	53 9a       	sbi	0x0a, 3	; 10
	PORTD |= (1 << PD0);
     1f0:	58 9a       	sbi	0x0b, 0	; 11
	PORTD |= (1 << PD1);
     1f2:	59 9a       	sbi	0x0b, 1	; 11


	//Pour l'UART en 0
	DDRE = DDRE & (~(1<<RXD0)); //En entrée
     1f4:	68 98       	cbi	0x0d, 0	; 13
	DDRE = DDRE | (1<<TXD0); //En sortie
     1f6:	69 9a       	sbi	0x0d, 1	; 13

	//Pour la télécommande
	DDRE &= ~(1<<RECEPT_TEL); //En entrée (PINE7)
     1f8:	6f 98       	cbi	0x0d, 7	; 13
     1fa:	08 95       	ret

000001fc <ConvertRxChannels>:
	//Voie 2, inclinaison avancer reculer
	//Voie 3, yawn
	
	
	//Consigne de vitesse de montée pour l'asservissement normal ...
	v->RxInCollective = v->RxChannels[0];
     1fc:	fc 01       	movw	r30, r24
     1fe:	ef 5a       	subi	r30, 0xAF	; 175
     200:	ff 4f       	sbci	r31, 0xFF	; 255
     202:	60 81       	ld	r22, Z
     204:	71 81       	ldd	r23, Z+1	; 0x01
     206:	78 96       	adiw	r30, 0x18	; 24
     208:	71 83       	std	Z+1, r23	; 0x01
     20a:	60 83       	st	Z, r22

	//v->RxInRoll = v->RxChannels[1];
	//v->RxInPitch = v->RxChannels[2];
	//v->RxInYaw = v->RxChannels[3];

    v->RxInRoll_Angle = v->RxChannels[1];
     20c:	32 96       	adiw	r30, 0x02	; 2
     20e:	dc 01       	movw	r26, r24
     210:	ad 5a       	subi	r26, 0xAD	; 173
     212:	bf 4f       	sbci	r27, 0xFF	; 255
     214:	2d 91       	ld	r18, X+
     216:	3c 91       	ld	r19, X
     218:	11 97       	sbiw	r26, 0x01	; 1
     21a:	31 83       	std	Z+1, r19	; 0x01
     21c:	20 83       	st	Z, r18
    v->RxInPitch_Angle = v->RxChannels[2];
     21e:	34 96       	adiw	r30, 0x04	; 4
     220:	12 96       	adiw	r26, 0x02	; 2
     222:	2d 91       	ld	r18, X+
     224:	3c 91       	ld	r19, X
     226:	11 97       	sbiw	r26, 0x01	; 1
     228:	31 83       	std	Z+1, r19	; 0x01
     22a:	20 83       	st	Z, r18
    v->RxInYaw_Angle = v->RxChannels[3];
     22c:	32 97       	sbiw	r30, 0x02	; 2
     22e:	12 96       	adiw	r26, 0x02	; 2
     230:	2d 91       	ld	r18, X+
     232:	3c 91       	ld	r19, X
     234:	31 83       	std	Z+1, r19	; 0x01
     236:	20 83       	st	Z, r18
	v->RxArmed = v->RxChannels[4];
     238:	74 97       	sbiw	r30, 0x14	; 20
     23a:	20 81       	ld	r18, Z
     23c:	31 81       	ldd	r19, Z+1	; 0x01
     23e:	b0 96       	adiw	r30, 0x20	; 32
     240:	31 83       	std	Z+1, r19	; 0x01
     242:	20 83       	st	Z, r18
	//v->RxInModeNav = v->RxChannels[5]; //SW2
	v->RxAsserHaut = v->RxChannels[6]; //SW3 (Channel 7) Permet de choisir entre un asservissement en hauteur/vitesse
     244:	7c 97       	sbiw	r30, 0x1c	; 28
     246:	40 81       	ld	r20, Z
     248:	51 81       	ldd	r21, Z+1	; 0x01
     24a:	b0 96       	adiw	r30, 0x20	; 32
     24c:	51 83       	std	Z+1, r21	; 0x01
     24e:	40 83       	st	Z, r20
	//v->RxInModeNav = v->RxChannels[7]; //SW1
	v->alt = temps_etat_haut_US;
     250:	a0 91 40 02 	lds	r26, 0x0240	; 0x800240 <temps_etat_haut_US>
     254:	b0 91 41 02 	lds	r27, 0x0241	; 0x800241 <temps_etat_haut_US+0x1>
     258:	34 96       	adiw	r30, 0x04	; 4
     25a:	b1 83       	std	Z+1, r27	; 0x01
     25c:	a0 83       	st	Z, r26
     25e:	f3 97       	sbiw	r30, 0x33	; 51
	//printf("RxArmed = %d\n",v->RxArmed);
	//printf("RxInCollective = %d\n",v->RxInCollective);
	
	//Si on est vraiment à zero, alors on active le flag du zero ...
	v->FlagCollectiveZero = 0;
	if (v->RxInCollective < 50){
     260:	62 33       	cpi	r22, 0x32	; 50
     262:	71 05       	cpc	r23, r1
     264:	14 f0       	brlt	.+4      	; 0x26a <ConvertRxChannels+0x6e>
	//printf("diz_timer = %d", diz_timer1);
	//printf("RxArmed = %d\n",v->RxArmed);
	//printf("RxInCollective = %d\n",v->RxInCollective);
	
	//Si on est vraiment à zero, alors on active le flag du zero ...
	v->FlagCollectiveZero = 0;
     266:	10 82       	st	Z, r1
     268:	02 c0       	rjmp	.+4      	; 0x26e <ConvertRxChannels+0x72>
	if (v->RxInCollective < 50){
		v->FlagCollectiveZero = 1;
     26a:	61 e0       	ldi	r22, 0x01	; 1
     26c:	60 83       	st	Z, r22
     26e:	dc 01       	movw	r26, r24
     270:	ab 57       	subi	r26, 0x7B	; 123
     272:	bf 4f       	sbci	r27, 0xFF	; 255
	}
		
	//Si le switch SW3 est en haut, on veut controller l'altitude
	//Si le switch SW3 est en bas, on veut controller la vitesse
	if (v->RxAsserHaut < 0)
     274:	57 ff       	sbrs	r21, 7
     276:	03 c0       	rjmp	.+6      	; 0x27e <ConvertRxChannels+0x82>
	{
		v->AsserHaut = 0; //Control de la vitesse
     278:	1d 92       	st	X+, r1
     27a:	1c 92       	st	X, r1
     27c:	04 c0       	rjmp	.+8      	; 0x286 <ConvertRxChannels+0x8a>
		//cli_led2(2);
		//set_led2();
	}
	else
	{
		v->AsserHaut = 1; //Control hauteur	
     27e:	41 e0       	ldi	r20, 0x01	; 1
     280:	50 e0       	ldi	r21, 0x00	; 0
     282:	4d 93       	st	X+, r20
     284:	5c 93       	st	X, r21
		//reset_led2();
	}
	
	//On regarde si c'est bien armé (=on pourra commencer à le piloter)
	if ((v->FlagArmed == 0) && (v->RxArmed>200) && (v->FlagCollectiveZero==1)) {
     286:	dc 01       	movw	r26, r24
     288:	a9 58       	subi	r26, 0x89	; 137
     28a:	bf 4f       	sbci	r27, 0xFF	; 255
     28c:	4d 91       	ld	r20, X+
     28e:	5c 91       	ld	r21, X
     290:	11 97       	sbiw	r26, 0x01	; 1
     292:	45 2b       	or	r20, r21
     294:	59 f4       	brne	.+22     	; 0x2ac <ConvertRxChannels+0xb0>
     296:	29 3c       	cpi	r18, 0xC9	; 201
     298:	31 05       	cpc	r19, r1
     29a:	44 f0       	brlt	.+16     	; 0x2ac <ConvertRxChannels+0xb0>
     29c:	20 81       	ld	r18, Z
     29e:	21 30       	cpi	r18, 0x01	; 1
     2a0:	69 f4       	brne	.+26     	; 0x2bc <ConvertRxChannels+0xc0>
//		gyros_calibrate(v);
		v->FlagArmed = 1;
     2a2:	21 e0       	ldi	r18, 0x01	; 1
     2a4:	30 e0       	ldi	r19, 0x00	; 0
     2a6:	2d 93       	st	X+, r18
     2a8:	3c 93       	st	X, r19
     2aa:	08 c0       	rjmp	.+16     	; 0x2bc <ConvertRxChannels+0xc0>
		//set_led1();
	}
	// ! désarmer en vol fait conserver les valeurs de Rxchannels
	if (v->RxArmed<-200 && (v->FlagCollectiveZero==1)) {
     2ac:	28 33       	cpi	r18, 0x38	; 56
     2ae:	3f 4f       	sbci	r19, 0xFF	; 255
     2b0:	2c f4       	brge	.+10     	; 0x2bc <ConvertRxChannels+0xc0>
     2b2:	20 81       	ld	r18, Z
     2b4:	21 30       	cpi	r18, 0x01	; 1
     2b6:	11 f4       	brne	.+4      	; 0x2bc <ConvertRxChannels+0xc0>
		v->FlagArmed = 0;
     2b8:	1d 92       	st	X+, r1
     2ba:	1c 92       	st	X, r1
		//reset_led1();
	}
	//Choix de mode de navigation
	v->Mode_Nav = 0;
     2bc:	dc 01       	movw	r26, r24
     2be:	a5 58       	subi	r26, 0x85	; 133
     2c0:	bf 4f       	sbci	r27, 0xFF	; 255
     2c2:	11 96       	adiw	r26, 0x01	; 1
     2c4:	1c 92       	st	X, r1
     2c6:	1e 92       	st	-X, r1
	if (v->RxInModeNav<-300) {v->Mode_Nav = 0;}
     2c8:	fc 01       	movw	r30, r24
     2ca:	ed 58       	subi	r30, 0x8D	; 141
     2cc:	ff 4f       	sbci	r31, 0xFF	; 255
     2ce:	80 81       	ld	r24, Z
     2d0:	91 81       	ldd	r25, Z+1	; 0x01
	if (v->RxInModeNav>-300 && v->RxInModeNav<300) {v->Mode_Nav = 1;}
     2d2:	9c 01       	movw	r18, r24
     2d4:	25 5d       	subi	r18, 0xD5	; 213
     2d6:	3e 4f       	sbci	r19, 0xFE	; 254
     2d8:	27 35       	cpi	r18, 0x57	; 87
     2da:	32 40       	sbci	r19, 0x02	; 2
     2dc:	18 f4       	brcc	.+6      	; 0x2e4 <ConvertRxChannels+0xe8>
     2de:	81 e0       	ldi	r24, 0x01	; 1
     2e0:	90 e0       	ldi	r25, 0x00	; 0
     2e2:	05 c0       	rjmp	.+10     	; 0x2ee <ConvertRxChannels+0xf2>
	if (v->RxInModeNav>300) {v->Mode_Nav = 2;}	
     2e4:	8d 32       	cpi	r24, 0x2D	; 45
     2e6:	91 40       	sbci	r25, 0x01	; 1
     2e8:	24 f0       	brlt	.+8      	; 0x2f2 <ConvertRxChannels+0xf6>
     2ea:	82 e0       	ldi	r24, 0x02	; 2
     2ec:	90 e0       	ldi	r25, 0x00	; 0
     2ee:	8d 93       	st	X+, r24
     2f0:	9c 93       	st	X, r25
     2f2:	08 95       	ret

000002f4 <init_vars>:
	
}

void init_vars(struct vars_t *v){
     2f4:	fc 01       	movw	r30, r24
	v->AccelX=0;
     2f6:	11 82       	std	Z+1, r1	; 0x01
     2f8:	10 82       	st	Z, r1
	v->AccelY=0;
     2fa:	13 82       	std	Z+3, r1	; 0x03
     2fc:	12 82       	std	Z+2, r1	; 0x02
	v->AccelZ=0;
     2fe:	15 82       	std	Z+5, r1	; 0x05
     300:	14 82       	std	Z+4, r1	; 0x04

	v->GyroX=0;
     302:	17 82       	std	Z+7, r1	; 0x07
     304:	16 82       	std	Z+6, r1	; 0x06
	v->GyroY=0;
     306:	11 86       	std	Z+9, r1	; 0x09
     308:	10 86       	std	Z+8, r1	; 0x08
	v->GyroZ=0;
     30a:	13 86       	std	Z+11, r1	; 0x0b
     30c:	12 86       	std	Z+10, r1	; 0x0a

	v->GyroXZero=0;
     30e:	13 8a       	std	Z+19, r1	; 0x13
     310:	12 8a       	std	Z+18, r1	; 0x12
	v->GyroYZero=0;
     312:	15 8a       	std	Z+21, r1	; 0x15
     314:	14 8a       	std	Z+20, r1	; 0x14
	v->GyroZZero=0;
     316:	17 8a       	std	Z+23, r1	; 0x17
     318:	16 8a       	std	Z+22, r1	; 0x16
	    
	// valeur des gyro convertis en °/s
	v->GyroXConv=0;
     31a:	11 8e       	std	Z+25, r1	; 0x19
     31c:	10 8e       	std	Z+24, r1	; 0x18
	v->GyroYConv=0;
     31e:	13 8e       	std	Z+27, r1	; 0x1b
     320:	12 8e       	std	Z+26, r1	; 0x1a
	v->GyroZConv=0;
     322:	15 8e       	std	Z+29, r1	; 0x1d
     324:	14 8e       	std	Z+28, r1	; 0x1c
	    
	v->hauteur=0;
     326:	16 8e       	std	Z+30, r1	; 0x1e
     328:	17 8e       	std	Z+31, r1	; 0x1f
     32a:	10 a2       	std	Z+32, r1	; 0x20
     32c:	11 a2       	std	Z+33, r1	; 0x21
	v->hauteur_prec=0;	//hauteur précédente
     32e:	12 a2       	std	Z+34, r1	; 0x22
     330:	13 a2       	std	Z+35, r1	; 0x23
     332:	14 a2       	std	Z+36, r1	; 0x24
     334:	15 a2       	std	Z+37, r1	; 0x25
	v->choix_asser_alt=0;	//Choix de l'asservissement (altitude (=0) ou vitesse verticale(=1))
     336:	17 a2       	std	Z+39, r1	; 0x27
     338:	16 a2       	std	Z+38, r1	; 0x26
	v->pos_manette_ver=0;	//Position de la manette pour la verticale
     33a:	11 a6       	std	Z+41, r1	; 0x29
     33c:	10 a6       	std	Z+40, r1	; 0x28
	v->coeff_asser=0;
     33e:	12 a6       	std	Z+42, r1	; 0x2a
     340:	13 a6       	std	Z+43, r1	; 0x2b
     342:	14 a6       	std	Z+44, r1	; 0x2c
     344:	15 a6       	std	Z+45, r1	; 0x2d
	    
	v->erreurh=0;
     346:	16 a6       	std	Z+46, r1	; 0x2e
     348:	17 a6       	std	Z+47, r1	; 0x2f
     34a:	10 aa       	std	Z+48, r1	; 0x30
     34c:	11 aa       	std	Z+49, r1	; 0x31
	v->erreurh_prec=0;//Erreur précédente
     34e:	12 aa       	std	Z+50, r1	; 0x32
     350:	13 aa       	std	Z+51, r1	; 0x33
     352:	14 aa       	std	Z+52, r1	; 0x34
     354:	15 aa       	std	Z+53, r1	; 0x35
	    
	v->erreur_vitesse_prec=0;
     356:	16 aa       	std	Z+54, r1	; 0x36
     358:	17 aa       	std	Z+55, r1	; 0x37
     35a:	10 ae       	std	Z+56, r1	; 0x38
     35c:	11 ae       	std	Z+57, r1	; 0x39
	v->erreur_vitesse=0;
     35e:	12 ae       	std	Z+58, r1	; 0x3a
     360:	13 ae       	std	Z+59, r1	; 0x3b
     362:	14 ae       	std	Z+60, r1	; 0x3c
     364:	15 ae       	std	Z+61, r1	; 0x3d
	v->vitesse=0;
     366:	dc 01       	movw	r26, r24
     368:	de 96       	adiw	r26, 0x3e	; 62
     36a:	1d 92       	st	X+, r1
     36c:	1d 92       	st	X+, r1
     36e:	1d 92       	st	X+, r1
     370:	1c 92       	st	X, r1
     372:	13 97       	sbiw	r26, 0x03	; 3
	v->vitesse_prec=0;
     374:	14 96       	adiw	r26, 0x04	; 4
     376:	1d 92       	st	X+, r1
     378:	1d 92       	st	X+, r1
     37a:	1d 92       	st	X+, r1
     37c:	1c 92       	st	X, r1
     37e:	13 97       	sbiw	r26, 0x03	; 3
	    
	v->MotorOut1=0;
     380:	14 96       	adiw	r26, 0x04	; 4
     382:	11 96       	adiw	r26, 0x01	; 1
     384:	1c 92       	st	X, r1
     386:	1e 92       	st	-X, r1
	v->MotorOut2=0;
     388:	12 96       	adiw	r26, 0x02	; 2
     38a:	11 96       	adiw	r26, 0x01	; 1
     38c:	1c 92       	st	X, r1
     38e:	1e 92       	st	-X, r1
	v->MotorOut3=0;
     390:	12 96       	adiw	r26, 0x02	; 2
     392:	11 96       	adiw	r26, 0x01	; 1
     394:	1c 92       	st	X, r1
     396:	1e 92       	st	-X, r1
	v->MotorOut4=0;
     398:	12 96       	adiw	r26, 0x02	; 2
     39a:	11 96       	adiw	r26, 0x01	; 1
     39c:	1c 92       	st	X, r1
     39e:	1e 92       	st	-X, r1
	    
	v->FlagCollectiveZero=0;
     3a0:	12 96       	adiw	r26, 0x02	; 2
     3a2:	1c 92       	st	X, r1
	v->coll_calc=0;//Collective calculé
     3a4:	11 96       	adiw	r26, 0x01	; 1
     3a6:	11 96       	adiw	r26, 0x01	; 1
     3a8:	1c 92       	st	X, r1
     3aa:	1e 92       	st	-X, r1
	v->RxInRoll=0; // -1000 +1000
     3ac:	54 96       	adiw	r26, 0x14	; 20
     3ae:	11 96       	adiw	r26, 0x01	; 1
     3b0:	1c 92       	st	X, r1
     3b2:	1e 92       	st	-X, r1
	v->RxInPitch=0; // -1000 +1000
     3b4:	12 96       	adiw	r26, 0x02	; 2
     3b6:	11 96       	adiw	r26, 0x01	; 1
     3b8:	1c 92       	st	X, r1
     3ba:	1e 92       	st	-X, r1
	v->RxInYaw=0; // -1000 +1000
     3bc:	12 96       	adiw	r26, 0x02	; 2
     3be:	11 96       	adiw	r26, 0x01	; 1
     3c0:	1c 92       	st	X, r1
     3c2:	1e 92       	st	-X, r1
	v->RxInRoll_Angle=0; // -1000 +1000
     3c4:	14 96       	adiw	r26, 0x04	; 4
     3c6:	11 96       	adiw	r26, 0x01	; 1
     3c8:	1c 92       	st	X, r1
     3ca:	1e 92       	st	-X, r1
	v->RxInPitch_Angle=0; // -1000 +1000
     3cc:	14 96       	adiw	r26, 0x04	; 4
     3ce:	11 96       	adiw	r26, 0x01	; 1
     3d0:	1c 92       	st	X, r1
     3d2:	1e 92       	st	-X, r1
	v->RxInYaw_Angle=0; // -1000 +1000
     3d4:	12 97       	sbiw	r26, 0x02	; 2
     3d6:	11 96       	adiw	r26, 0x01	; 1
     3d8:	1c 92       	st	X, r1
     3da:	1e 92       	st	-X, r1
	v->RxInCollective=0; // 0 +1000
     3dc:	14 97       	sbiw	r26, 0x04	; 4
     3de:	11 96       	adiw	r26, 0x01	; 1
     3e0:	1c 92       	st	X, r1
     3e2:	1e 92       	st	-X, r1
	//unsigned int height, cons_height; // 0 +1000
	v->computedCollective=0; // 0 +1000
     3e4:	18 96       	adiw	r26, 0x08	; 8
     3e6:	11 96       	adiw	r26, 0x01	; 1
     3e8:	1c 92       	st	X, r1
     3ea:	1e 92       	st	-X, r1
	v->RxInModeNav=0;
     3ec:	12 96       	adiw	r26, 0x02	; 2
     3ee:	11 96       	adiw	r26, 0x01	; 1
     3f0:	1c 92       	st	X, r1
     3f2:	1e 92       	st	-X, r1
	v->oldRxInMode=0; // -1000 +1000
     3f4:	12 96       	adiw	r26, 0x02	; 2
     3f6:	11 96       	adiw	r26, 0x01	; 1
     3f8:	1c 92       	st	X, r1
     3fa:	1e 92       	st	-X, r1
	v->FlagArmed=0;  //indique si on est désarmé ou armé
     3fc:	12 96       	adiw	r26, 0x02	; 2
     3fe:	11 96       	adiw	r26, 0x01	; 1
     400:	1c 92       	st	X, r1
     402:	1e 92       	st	-X, r1
	v->RxArmed=0;
     404:	12 96       	adiw	r26, 0x02	; 2
     406:	11 96       	adiw	r26, 0x01	; 1
     408:	1c 92       	st	X, r1
     40a:	1e 92       	st	-X, r1
	v->Mode_Nav=0;
     40c:	12 96       	adiw	r26, 0x02	; 2
     40e:	1d 92       	st	X+, r1
     410:	1c 92       	st	X, r1
	    
	v->YawLimit=400;
     412:	e1 58       	subi	r30, 0x81	; 129
     414:	ff 4f       	sbci	r31, 0xFF	; 255
     416:	80 e9       	ldi	r24, 0x90	; 144
     418:	91 e0       	ldi	r25, 0x01	; 1
     41a:	91 83       	std	Z+1, r25	; 0x01
     41c:	80 83       	st	Z, r24
     41e:	08 95       	ret

00000420 <output_motors>:
//Voie 0, premier signal : Monter/descendre
//Voie 1,inclinaison latéralgauche/droite (roll)
//Voie 2, inclinaison avancer reculer
//Voie 3, yawn

void output_motors(struct vars_t *v){
     420:	0f 93       	push	r16
     422:	1f 93       	push	r17
     424:	cf 93       	push	r28
     426:	df 93       	push	r29
	//Saturation en O % :
	if (v->MotorOut1<0) {v->MotorOut1=0;}
     428:	9c 01       	movw	r18, r24
     42a:	2a 5b       	subi	r18, 0xBA	; 186
     42c:	3f 4f       	sbci	r19, 0xFF	; 255
     42e:	f9 01       	movw	r30, r18
     430:	40 81       	ld	r20, Z
     432:	51 81       	ldd	r21, Z+1	; 0x01
     434:	57 ff       	sbrs	r21, 7
     436:	02 c0       	rjmp	.+4      	; 0x43c <output_motors+0x1c>
     438:	11 82       	std	Z+1, r1	; 0x01
     43a:	10 82       	st	Z, r1
	if (v->MotorOut2<0) {v->MotorOut2=0;}
     43c:	ec 01       	movw	r28, r24
     43e:	c8 5b       	subi	r28, 0xB8	; 184
     440:	df 4f       	sbci	r29, 0xFF	; 255
     442:	48 81       	ld	r20, Y
     444:	59 81       	ldd	r21, Y+1	; 0x01
     446:	57 ff       	sbrs	r21, 7
     448:	02 c0       	rjmp	.+4      	; 0x44e <output_motors+0x2e>
     44a:	19 82       	std	Y+1, r1	; 0x01
     44c:	18 82       	st	Y, r1
	if (v->MotorOut3<0) {v->MotorOut3=0;}
     44e:	dc 01       	movw	r26, r24
     450:	a6 5b       	subi	r26, 0xB6	; 182
     452:	bf 4f       	sbci	r27, 0xFF	; 255
     454:	4d 91       	ld	r20, X+
     456:	5c 91       	ld	r21, X
     458:	11 97       	sbiw	r26, 0x01	; 1
     45a:	57 ff       	sbrs	r21, 7
     45c:	03 c0       	rjmp	.+6      	; 0x464 <output_motors+0x44>
     45e:	11 96       	adiw	r26, 0x01	; 1
     460:	1c 92       	st	X, r1
     462:	1e 92       	st	-X, r1
	if (v->MotorOut4<0) {v->MotorOut4=0;}
     464:	8c 01       	movw	r16, r24
     466:	04 5b       	subi	r16, 0xB4	; 180
     468:	1f 4f       	sbci	r17, 0xFF	; 255
     46a:	f8 01       	movw	r30, r16
     46c:	40 81       	ld	r20, Z
     46e:	51 81       	ldd	r21, Z+1	; 0x01
     470:	57 ff       	sbrs	r21, 7
     472:	02 c0       	rjmp	.+4      	; 0x478 <output_motors+0x58>
     474:	11 82       	std	Z+1, r1	; 0x01
     476:	10 82       	st	Z, r1
		
	//Saturation en 100 % :
	if (v->MotorOut1>1000) {v->MotorOut1=1000;}
     478:	f9 01       	movw	r30, r18
     47a:	40 81       	ld	r20, Z
     47c:	51 81       	ldd	r21, Z+1	; 0x01
     47e:	49 3e       	cpi	r20, 0xE9	; 233
     480:	53 40       	sbci	r21, 0x03	; 3
     482:	2c f0       	brlt	.+10     	; 0x48e <output_motors+0x6e>
     484:	48 ee       	ldi	r20, 0xE8	; 232
     486:	53 e0       	ldi	r21, 0x03	; 3
     488:	f9 01       	movw	r30, r18
     48a:	51 83       	std	Z+1, r21	; 0x01
     48c:	40 83       	st	Z, r20
	if (v->MotorOut2>1000) {v->MotorOut2=1000;}
     48e:	48 81       	ld	r20, Y
     490:	59 81       	ldd	r21, Y+1	; 0x01
     492:	49 3e       	cpi	r20, 0xE9	; 233
     494:	53 40       	sbci	r21, 0x03	; 3
     496:	24 f0       	brlt	.+8      	; 0x4a0 <output_motors+0x80>
     498:	48 ee       	ldi	r20, 0xE8	; 232
     49a:	53 e0       	ldi	r21, 0x03	; 3
     49c:	59 83       	std	Y+1, r21	; 0x01
     49e:	48 83       	st	Y, r20
	if (v->MotorOut3>1000) {v->MotorOut3=1000;}
     4a0:	4d 91       	ld	r20, X+
     4a2:	5c 91       	ld	r21, X
     4a4:	11 97       	sbiw	r26, 0x01	; 1
     4a6:	49 3e       	cpi	r20, 0xE9	; 233
     4a8:	53 40       	sbci	r21, 0x03	; 3
     4aa:	2c f0       	brlt	.+10     	; 0x4b6 <output_motors+0x96>
     4ac:	48 ee       	ldi	r20, 0xE8	; 232
     4ae:	53 e0       	ldi	r21, 0x03	; 3
     4b0:	11 96       	adiw	r26, 0x01	; 1
     4b2:	5c 93       	st	X, r21
     4b4:	4e 93       	st	-X, r20
	if (v->MotorOut4>1000) {v->MotorOut4=1000;}
     4b6:	f8 01       	movw	r30, r16
     4b8:	40 81       	ld	r20, Z
     4ba:	51 81       	ldd	r21, Z+1	; 0x01
     4bc:	49 3e       	cpi	r20, 0xE9	; 233
     4be:	53 40       	sbci	r21, 0x03	; 3
     4c0:	2c f0       	brlt	.+10     	; 0x4cc <output_motors+0xac>
     4c2:	48 ee       	ldi	r20, 0xE8	; 232
     4c4:	53 e0       	ldi	r21, 0x03	; 3
     4c6:	f8 01       	movw	r30, r16
     4c8:	51 83       	std	Z+1, r21	; 0x01
     4ca:	40 83       	st	Z, r20
	
	//Si les manches indiquent les moteurs à zeros, alors :
	if (v->FlagCollectiveZero==1){
     4cc:	82 5b       	subi	r24, 0xB2	; 178
     4ce:	9f 4f       	sbci	r25, 0xFF	; 255
     4d0:	fc 01       	movw	r30, r24
     4d2:	80 81       	ld	r24, Z
     4d4:	81 30       	cpi	r24, 0x01	; 1
     4d6:	59 f4       	brne	.+22     	; 0x4ee <output_motors+0xce>
		v->MotorOut1=0;
     4d8:	f9 01       	movw	r30, r18
     4da:	11 82       	std	Z+1, r1	; 0x01
     4dc:	10 82       	st	Z, r1
		v->MotorOut2=0;
     4de:	19 82       	std	Y+1, r1	; 0x01
     4e0:	18 82       	st	Y, r1
		v->MotorOut3=0;
     4e2:	11 96       	adiw	r26, 0x01	; 1
     4e4:	1c 92       	st	X, r1
     4e6:	1e 92       	st	-X, r1
		v->MotorOut4=0;
     4e8:	f8 01       	movw	r30, r16
     4ea:	11 82       	std	Z+1, r1	; 0x01
     4ec:	10 82       	st	Z, r1
	}
	
	//Scale :
	v->MotorOut1+=1000;
     4ee:	f9 01       	movw	r30, r18
     4f0:	80 81       	ld	r24, Z
     4f2:	91 81       	ldd	r25, Z+1	; 0x01
     4f4:	88 51       	subi	r24, 0x18	; 24
     4f6:	9c 4f       	sbci	r25, 0xFC	; 252
     4f8:	91 83       	std	Z+1, r25	; 0x01
     4fa:	80 83       	st	Z, r24
	v->MotorOut2+=1000;
     4fc:	28 81       	ld	r18, Y
     4fe:	39 81       	ldd	r19, Y+1	; 0x01
     500:	28 51       	subi	r18, 0x18	; 24
     502:	3c 4f       	sbci	r19, 0xFC	; 252
     504:	39 83       	std	Y+1, r19	; 0x01
     506:	28 83       	st	Y, r18
	v->MotorOut3+=1000;
     508:	2d 91       	ld	r18, X+
     50a:	3c 91       	ld	r19, X
     50c:	11 97       	sbiw	r26, 0x01	; 1
     50e:	28 51       	subi	r18, 0x18	; 24
     510:	3c 4f       	sbci	r19, 0xFC	; 252
     512:	11 96       	adiw	r26, 0x01	; 1
     514:	3c 93       	st	X, r19
     516:	2e 93       	st	-X, r18
	v->MotorOut4+=1000;
     518:	f8 01       	movw	r30, r16
     51a:	20 81       	ld	r18, Z
     51c:	31 81       	ldd	r19, Z+1	; 0x01
     51e:	28 51       	subi	r18, 0x18	; 24
     520:	3c 4f       	sbci	r19, 0xFC	; 252
     522:	31 83       	std	Z+1, r19	; 0x01
     524:	20 83       	st	Z, r18
	
	//printf("MotorOut1 = %d, MotorOut2 = %d, MotorOut3 = %d, MotorOut4 = %d\r",v->MotorOut1,v->MotorOut2,v->MotorOut3,v->MotorOut4);
	//Sortie finale :
	OCR4A = v->MotorOut1; //M1
     526:	90 93 a9 00 	sts	0x00A9, r25	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>
     52a:	80 93 a8 00 	sts	0x00A8, r24	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7e00a8>
	OCR4B = v->MotorOut2; //M2
     52e:	88 81       	ld	r24, Y
     530:	99 81       	ldd	r25, Y+1	; 0x01
     532:	90 93 ab 00 	sts	0x00AB, r25	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7e00ab>
     536:	80 93 aa 00 	sts	0x00AA, r24	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7e00aa>
	OCR4C = v->MotorOut3; //M3
     53a:	8d 91       	ld	r24, X+
     53c:	9c 91       	ld	r25, X
     53e:	90 93 ad 00 	sts	0x00AD, r25	; 0x8000ad <__TEXT_REGION_LENGTH__+0x7e00ad>
     542:	80 93 ac 00 	sts	0x00AC, r24	; 0x8000ac <__TEXT_REGION_LENGTH__+0x7e00ac>
	OCR5A = v->MotorOut4; //M4
     546:	80 81       	ld	r24, Z
     548:	91 81       	ldd	r25, Z+1	; 0x01
     54a:	90 93 29 01 	sts	0x0129, r25	; 0x800129 <__TEXT_REGION_LENGTH__+0x7e0129>
     54e:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <__TEXT_REGION_LENGTH__+0x7e0128>
}
     552:	df 91       	pop	r29
     554:	cf 91       	pop	r28
     556:	1f 91       	pop	r17
     558:	0f 91       	pop	r16
     55a:	08 95       	ret

0000055c <init_motors_pids>:

void init_motors_pids() {
	pid_Init(K_ROLL_P * SCALING_FACTOR, K_ROLL_I * SCALING_FACTOR , K_ROLL_D * SCALING_FACTOR , &pidData_roll);
     55c:	2b e9       	ldi	r18, 0x9B	; 155
     55e:	32 e0       	ldi	r19, 0x02	; 2
     560:	40 e0       	ldi	r20, 0x00	; 0
     562:	50 e0       	ldi	r21, 0x00	; 0
     564:	60 e0       	ldi	r22, 0x00	; 0
     566:	70 e0       	ldi	r23, 0x00	; 0
     568:	80 e4       	ldi	r24, 0x40	; 64
     56a:	90 e0       	ldi	r25, 0x00	; 0
     56c:	0e 94 f4 06 	call	0xde8	; 0xde8 <pid_Init>
	pid_Init(K_PITCH_P * SCALING_FACTOR, K_PITCH_I * SCALING_FACTOR , K_PITCH_D * SCALING_FACTOR , &pidData_pitch);
     570:	2f eb       	ldi	r18, 0xBF	; 191
     572:	32 e0       	ldi	r19, 0x02	; 2
     574:	40 e0       	ldi	r20, 0x00	; 0
     576:	50 e0       	ldi	r21, 0x00	; 0
     578:	60 e0       	ldi	r22, 0x00	; 0
     57a:	70 e0       	ldi	r23, 0x00	; 0
     57c:	80 e4       	ldi	r24, 0x40	; 64
     57e:	90 e0       	ldi	r25, 0x00	; 0
     580:	0e 94 f4 06 	call	0xde8	; 0xde8 <pid_Init>
	pid_Init(K_YAW_P * SCALING_FACTOR, K_YAW_I * SCALING_FACTOR , K_YAW_D * SCALING_FACTOR , &pidData_yaw);
     584:	26 e7       	ldi	r18, 0x76	; 118
     586:	32 e0       	ldi	r19, 0x02	; 2
     588:	40 e0       	ldi	r20, 0x00	; 0
     58a:	50 e0       	ldi	r21, 0x00	; 0
     58c:	60 e0       	ldi	r22, 0x00	; 0
     58e:	70 e0       	ldi	r23, 0x00	; 0
     590:	81 e0       	ldi	r24, 0x01	; 1
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	0e 94 f4 06 	call	0xde8	; 0xde8 <pid_Init>
		
	pid_Init(K_ROLL_P2 * SCALING_FACTOR, K_ROLL_I2 * SCALING_FACTOR , K_ROLL_D2 * SCALING_FACTOR , &pidData_roll2);
     598:	2d ea       	ldi	r18, 0xAD	; 173
     59a:	32 e0       	ldi	r19, 0x02	; 2
     59c:	40 e0       	ldi	r20, 0x00	; 0
     59e:	50 e0       	ldi	r21, 0x00	; 0
     5a0:	60 e0       	ldi	r22, 0x00	; 0
     5a2:	70 e0       	ldi	r23, 0x00	; 0
     5a4:	81 e0       	ldi	r24, 0x01	; 1
     5a6:	90 e0       	ldi	r25, 0x00	; 0
     5a8:	0e 94 f4 06 	call	0xde8	; 0xde8 <pid_Init>
	pid_Init(K_PITCH_P2 * SCALING_FACTOR, K_PITCH_I2 * SCALING_FACTOR , K_PITCH_D2 * SCALING_FACTOR , &pidData_pitch2);
     5ac:	21 ed       	ldi	r18, 0xD1	; 209
     5ae:	32 e0       	ldi	r19, 0x02	; 2
     5b0:	40 e0       	ldi	r20, 0x00	; 0
     5b2:	50 e0       	ldi	r21, 0x00	; 0
     5b4:	60 e0       	ldi	r22, 0x00	; 0
     5b6:	70 e0       	ldi	r23, 0x00	; 0
     5b8:	81 e0       	ldi	r24, 0x01	; 1
     5ba:	90 e0       	ldi	r25, 0x00	; 0
     5bc:	0e 94 f4 06 	call	0xde8	; 0xde8 <pid_Init>
	pid_Init(K_YAW_P2 * SCALING_FACTOR, K_YAW_I2 * SCALING_FACTOR , K_YAW_D2 * SCALING_FACTOR , &pidData_yaw2);
     5c0:	28 e8       	ldi	r18, 0x88	; 136
     5c2:	32 e0       	ldi	r19, 0x02	; 2
     5c4:	40 e0       	ldi	r20, 0x00	; 0
     5c6:	50 e0       	ldi	r21, 0x00	; 0
     5c8:	60 e0       	ldi	r22, 0x00	; 0
     5ca:	70 e0       	ldi	r23, 0x00	; 0
     5cc:	8c e0       	ldi	r24, 0x0C	; 12
     5ce:	90 e0       	ldi	r25, 0x00	; 0
     5d0:	0c 94 f4 06 	jmp	0xde8	; 0xde8 <pid_Init>

000005d4 <reset_motors_pids>:
}

void reset_motors_pids() {
	pid_Reset_Integrator(&pidData_roll);
     5d4:	8b e9       	ldi	r24, 0x9B	; 155
     5d6:	92 e0       	ldi	r25, 0x02	; 2
     5d8:	0e 94 b6 07 	call	0xf6c	; 0xf6c <pid_Reset_Integrator>
	pid_Reset_Integrator(&pidData_pitch);
     5dc:	8f eb       	ldi	r24, 0xBF	; 191
     5de:	92 e0       	ldi	r25, 0x02	; 2
     5e0:	0e 94 b6 07 	call	0xf6c	; 0xf6c <pid_Reset_Integrator>
	pid_Reset_Integrator(&pidData_yaw);
     5e4:	86 e7       	ldi	r24, 0x76	; 118
     5e6:	92 e0       	ldi	r25, 0x02	; 2
     5e8:	0e 94 b6 07 	call	0xf6c	; 0xf6c <pid_Reset_Integrator>
	
	pid_Reset_Integrator(&pidData_roll2);
     5ec:	8d ea       	ldi	r24, 0xAD	; 173
     5ee:	92 e0       	ldi	r25, 0x02	; 2
     5f0:	0e 94 b6 07 	call	0xf6c	; 0xf6c <pid_Reset_Integrator>
	pid_Reset_Integrator(&pidData_pitch2);
     5f4:	81 ed       	ldi	r24, 0xD1	; 209
     5f6:	92 e0       	ldi	r25, 0x02	; 2
     5f8:	0e 94 b6 07 	call	0xf6c	; 0xf6c <pid_Reset_Integrator>
	pid_Reset_Integrator(&pidData_yaw2);
     5fc:	88 e8       	ldi	r24, 0x88	; 136
     5fe:	92 e0       	ldi	r25, 0x02	; 2
     600:	0c 94 b6 07 	jmp	0xf6c	; 0xf6c <pid_Reset_Integrator>

00000604 <computedata_motors>:
}


void computedata_motors(struct vars_t *v){
     604:	af 92       	push	r10
     606:	bf 92       	push	r11
     608:	cf 92       	push	r12
     60a:	df 92       	push	r13
     60c:	ef 92       	push	r14
     60e:	ff 92       	push	r15
     610:	0f 93       	push	r16
     612:	1f 93       	push	r17
     614:	cf 93       	push	r28
     616:	df 93       	push	r29
     618:	ec 01       	movw	r28, r24
		int y, y1;
		int z;
		int col;
		
		//saturation si le collectif est trop elevé
		col = v->computedCollective;
     61a:	fc 01       	movw	r30, r24
     61c:	ef 58       	subi	r30, 0x8F	; 143
     61e:	ff 4f       	sbci	r31, 0xFF	; 255
     620:	80 81       	ld	r24, Z
     622:	91 81       	ldd	r25, Z+1	; 0x01
     624:	89 3e       	cpi	r24, 0xE9	; 233
     626:	23 e0       	ldi	r18, 0x03	; 3
     628:	92 07       	cpc	r25, r18
     62a:	14 f0       	brlt	.+4      	; 0x630 <computedata_motors+0x2c>
     62c:	88 ee       	ldi	r24, 0xE8	; 232
     62e:	93 e0       	ldi	r25, 0x03	; 3
		
		if (col > MAX_MOTORS) {
			col = MAX_MOTORS;
		}
		// start mixing
		v->MotorOut1 = col;
     630:	5e 01       	movw	r10, r28
     632:	46 e4       	ldi	r20, 0x46	; 70
     634:	a4 0e       	add	r10, r20
     636:	b1 1c       	adc	r11, r1
     638:	d5 01       	movw	r26, r10
     63a:	8d 93       	st	X+, r24
     63c:	9c 93       	st	X, r25
		v->MotorOut2 = col;
     63e:	6e 01       	movw	r12, r28
     640:	b8 e4       	ldi	r27, 0x48	; 72
     642:	cb 0e       	add	r12, r27
     644:	d1 1c       	adc	r13, r1
     646:	f6 01       	movw	r30, r12
     648:	91 83       	std	Z+1, r25	; 0x01
     64a:	80 83       	st	Z, r24
		v->MotorOut3 = col;
     64c:	7e 01       	movw	r14, r28
     64e:	fa e4       	ldi	r31, 0x4A	; 74
     650:	ef 0e       	add	r14, r31
     652:	f1 1c       	adc	r15, r1
     654:	d7 01       	movw	r26, r14
     656:	8d 93       	st	X+, r24
     658:	9c 93       	st	X, r25
		v->MotorOut4 = col;
     65a:	8e 01       	movw	r16, r28
     65c:	04 5b       	subi	r16, 0xB4	; 180
     65e:	1f 4f       	sbci	r17, 0xFF	; 255
     660:	f8 01       	movw	r30, r16
     662:	91 83       	std	Z+1, r25	; 0x01
     664:	80 83       	st	Z, r24

		// Calculate roll command output

		y1 = (v->RxInRoll_Angle - v->AngleX)*8;
//		y1 = pid_Controller(v->RxInRoll_Angle, v->AngleX, &pidData_roll);
		y = pid_Controller(y1, v->GyroX, &pidData_roll2);
     666:	6e 81       	ldd	r22, Y+6	; 0x06
     668:	7f 81       	ldd	r23, Y+7	; 0x07
		v->MotorOut3 = col;
		v->MotorOut4 = col;

		// Calculate roll command output

		y1 = (v->RxInRoll_Angle - v->AngleX)*8;
     66a:	7f 96       	adiw	r30, 0x1f	; 31
     66c:	80 81       	ld	r24, Z
     66e:	91 81       	ldd	r25, Z+1	; 0x01
     670:	2c 85       	ldd	r18, Y+12	; 0x0c
     672:	3d 85       	ldd	r19, Y+13	; 0x0d
     674:	82 1b       	sub	r24, r18
     676:	93 0b       	sbc	r25, r19
//		y1 = pid_Controller(v->RxInRoll_Angle, v->AngleX, &pidData_roll);
		y = pid_Controller(y1, v->GyroX, &pidData_roll2);
     678:	4d ea       	ldi	r20, 0xAD	; 173
     67a:	52 e0       	ldi	r21, 0x02	; 2
     67c:	23 e0       	ldi	r18, 0x03	; 3
     67e:	88 0f       	add	r24, r24
     680:	99 1f       	adc	r25, r25
     682:	2a 95       	dec	r18
     684:	e1 f7       	brne	.-8      	; 0x67e <computedata_motors+0x7a>
     686:	0e 94 21 07 	call	0xe42	; 0xe42 <pid_Controller>
		//y = pid_Controller(v->RxInRoll_Angle, v->GyroX, &pidData_roll);
		
		//z = pid_Controller(v->y*(RxInRoll_Angle-, v->GyroX, &pidData_roll);

		// Add roll command output to motor 2 and 3
		v->MotorOut1 += y;
     68a:	d5 01       	movw	r26, r10
     68c:	2d 91       	ld	r18, X+
     68e:	3c 91       	ld	r19, X
     690:	11 97       	sbiw	r26, 0x01	; 1
     692:	28 0f       	add	r18, r24
     694:	39 1f       	adc	r19, r25
     696:	2d 93       	st	X+, r18
     698:	3c 93       	st	X, r19
		v->MotorOut2 -= y;
     69a:	f6 01       	movw	r30, r12
     69c:	20 81       	ld	r18, Z
     69e:	31 81       	ldd	r19, Z+1	; 0x01
     6a0:	28 1b       	sub	r18, r24
     6a2:	39 0b       	sbc	r19, r25
     6a4:	31 83       	std	Z+1, r19	; 0x01
     6a6:	20 83       	st	Z, r18
		v->MotorOut3 -= y;
     6a8:	d7 01       	movw	r26, r14
     6aa:	2d 91       	ld	r18, X+
     6ac:	3c 91       	ld	r19, X
     6ae:	11 97       	sbiw	r26, 0x01	; 1
     6b0:	28 1b       	sub	r18, r24
     6b2:	39 0b       	sbc	r19, r25
     6b4:	2d 93       	st	X+, r18
     6b6:	3c 93       	st	X, r19
		v->MotorOut4 += y;
     6b8:	f8 01       	movw	r30, r16
     6ba:	20 81       	ld	r18, Z
     6bc:	31 81       	ldd	r19, Z+1	; 0x01
     6be:	82 0f       	add	r24, r18
     6c0:	93 1f       	adc	r25, r19
     6c2:	91 83       	std	Z+1, r25	; 0x01
     6c4:	80 83       	st	Z, r24

		// Calculate pitch command output
		
		y1 = (v->RxInPitch_Angle - v->AngleY)*8;
//		y1 = pid_Controller(v->RxInPitch_Angle, v->AngleY, &pidData_pitch);
		y = pid_Controller(y1, v->GyroY, &pidData_pitch2);
     6c6:	68 85       	ldd	r22, Y+8	; 0x08
     6c8:	79 85       	ldd	r23, Y+9	; 0x09
		v->MotorOut3 -= y;
		v->MotorOut4 += y;

		// Calculate pitch command output
		
		y1 = (v->RxInPitch_Angle - v->AngleY)*8;
     6ca:	b3 96       	adiw	r30, 0x23	; 35
     6cc:	80 81       	ld	r24, Z
     6ce:	91 81       	ldd	r25, Z+1	; 0x01
     6d0:	2e 85       	ldd	r18, Y+14	; 0x0e
     6d2:	3f 85       	ldd	r19, Y+15	; 0x0f
     6d4:	82 1b       	sub	r24, r18
     6d6:	93 0b       	sbc	r25, r19
//		y1 = pid_Controller(v->RxInPitch_Angle, v->AngleY, &pidData_pitch);
		y = pid_Controller(y1, v->GyroY, &pidData_pitch2);
     6d8:	41 ed       	ldi	r20, 0xD1	; 209
     6da:	52 e0       	ldi	r21, 0x02	; 2
     6dc:	33 e0       	ldi	r19, 0x03	; 3
     6de:	88 0f       	add	r24, r24
     6e0:	99 1f       	adc	r25, r25
     6e2:	3a 95       	dec	r19
     6e4:	e1 f7       	brne	.-8      	; 0x6de <computedata_motors+0xda>
     6e6:	0e 94 21 07 	call	0xe42	; 0xe42 <pid_Controller>
		//y = pid_Controller(v->RxInPitch_Angle, v->GyroY, &pidData_pitch);

		// Add Pitch command output to motor 1 and 4
		v->MotorOut1 += y;
     6ea:	d5 01       	movw	r26, r10
     6ec:	2d 91       	ld	r18, X+
     6ee:	3c 91       	ld	r19, X
     6f0:	11 97       	sbiw	r26, 0x01	; 1
     6f2:	28 0f       	add	r18, r24
     6f4:	39 1f       	adc	r19, r25
     6f6:	2d 93       	st	X+, r18
     6f8:	3c 93       	st	X, r19
		v->MotorOut2 += y;
     6fa:	f6 01       	movw	r30, r12
     6fc:	20 81       	ld	r18, Z
     6fe:	31 81       	ldd	r19, Z+1	; 0x01
     700:	28 0f       	add	r18, r24
     702:	39 1f       	adc	r19, r25
     704:	31 83       	std	Z+1, r19	; 0x01
     706:	20 83       	st	Z, r18
		v->MotorOut3 -= y;
     708:	d7 01       	movw	r26, r14
     70a:	2d 91       	ld	r18, X+
     70c:	3c 91       	ld	r19, X
     70e:	11 97       	sbiw	r26, 0x01	; 1
     710:	28 1b       	sub	r18, r24
     712:	39 0b       	sbc	r19, r25
     714:	2d 93       	st	X+, r18
     716:	3c 93       	st	X, r19
		v->MotorOut4 -= y;
     718:	f8 01       	movw	r30, r16
     71a:	20 81       	ld	r18, Z
     71c:	31 81       	ldd	r19, Z+1	; 0x01
     71e:	a9 01       	movw	r20, r18
     720:	48 1b       	sub	r20, r24
     722:	59 0b       	sbc	r21, r25
     724:	51 83       	std	Z+1, r21	; 0x01
     726:	40 83       	st	Z, r20

		// Calculate Yaw command output
		
//		y1 = (-v->RxInYaw_Angle - v->AngleZ)*8;
//		y1 = pid_Controller(-v->RxInYaw_Angle, v->AngleZ, &pidData_yaw);
		y = pid_Controller(-v->RxInYaw_Angle, v->GyroZ, &pidData_yaw2);
     728:	6a 85       	ldd	r22, Y+10	; 0x0a
     72a:	7b 85       	ldd	r23, Y+11	; 0x0b
     72c:	c3 59       	subi	r28, 0x93	; 147
     72e:	df 4f       	sbci	r29, 0xFF	; 255
     730:	88 81       	ld	r24, Y
     732:	99 81       	ldd	r25, Y+1	; 0x01
     734:	48 e8       	ldi	r20, 0x88	; 136
     736:	52 e0       	ldi	r21, 0x02	; 2
     738:	91 95       	neg	r25
     73a:	81 95       	neg	r24
     73c:	91 09       	sbc	r25, r1
     73e:	0e 94 21 07 	call	0xe42	; 0xe42 <pid_Controller>
		// limit Yaw command to -YawLimit and YawLimit
		//if (y < -(v->YawLimit)){y = -(v->YawLimit);}
		//if (y > v->YawLimit){y = v->YawLimit;}
		
		// Add Yaw command output to motor 1, 2, 3 and 4
		v->MotorOut1 += y;
     742:	d5 01       	movw	r26, r10
     744:	6d 91       	ld	r22, X+
     746:	7c 91       	ld	r23, X
     748:	11 97       	sbiw	r26, 0x01	; 1
     74a:	68 0f       	add	r22, r24
     74c:	79 1f       	adc	r23, r25
     74e:	6d 93       	st	X+, r22
     750:	7c 93       	st	X, r23
		v->MotorOut2 -= y;
     752:	f6 01       	movw	r30, r12
     754:	40 81       	ld	r20, Z
     756:	51 81       	ldd	r21, Z+1	; 0x01
     758:	48 1b       	sub	r20, r24
     75a:	59 0b       	sbc	r21, r25
     75c:	51 83       	std	Z+1, r21	; 0x01
     75e:	40 83       	st	Z, r20
		v->MotorOut3 += y;
     760:	d7 01       	movw	r26, r14
     762:	2d 91       	ld	r18, X+
     764:	3c 91       	ld	r19, X
     766:	11 97       	sbiw	r26, 0x01	; 1
     768:	28 0f       	add	r18, r24
     76a:	39 1f       	adc	r19, r25
     76c:	2d 93       	st	X+, r18
     76e:	3c 93       	st	X, r19
		v->MotorOut4 -= y;
     770:	d8 01       	movw	r26, r16
     772:	ed 91       	ld	r30, X+
     774:	fc 91       	ld	r31, X
     776:	df 01       	movw	r26, r30
     778:	a8 1b       	sub	r26, r24
     77a:	b9 0b       	sbc	r27, r25
     77c:	cd 01       	movw	r24, r26
     77e:	f8 01       	movw	r30, r16
     780:	b1 83       	std	Z+1, r27	; 0x01
     782:	a0 83       	st	Z, r26

		if (v->MotorOut1 < LOWVALUE)
     784:	64 31       	cpi	r22, 0x14	; 20
     786:	71 05       	cpc	r23, r1
     788:	2c f4       	brge	.+10     	; 0x794 <computedata_motors+0x190>
			v->MotorOut1 = LOWVALUE;
     78a:	64 e1       	ldi	r22, 0x14	; 20
     78c:	70 e0       	ldi	r23, 0x00	; 0
     78e:	d5 01       	movw	r26, r10
     790:	6d 93       	st	X+, r22
     792:	7c 93       	st	X, r23
		if (v->MotorOut2 < LOWVALUE)
     794:	44 31       	cpi	r20, 0x14	; 20
     796:	51 05       	cpc	r21, r1
     798:	2c f4       	brge	.+10     	; 0x7a4 <computedata_motors+0x1a0>
			v->MotorOut2 = LOWVALUE;
     79a:	44 e1       	ldi	r20, 0x14	; 20
     79c:	50 e0       	ldi	r21, 0x00	; 0
     79e:	f6 01       	movw	r30, r12
     7a0:	51 83       	std	Z+1, r21	; 0x01
     7a2:	40 83       	st	Z, r20
		if (v->MotorOut3 < LOWVALUE)
     7a4:	24 31       	cpi	r18, 0x14	; 20
     7a6:	31 05       	cpc	r19, r1
     7a8:	2c f4       	brge	.+10     	; 0x7b4 <computedata_motors+0x1b0>
			v->MotorOut3 = LOWVALUE;
     7aa:	24 e1       	ldi	r18, 0x14	; 20
     7ac:	30 e0       	ldi	r19, 0x00	; 0
     7ae:	d7 01       	movw	r26, r14
     7b0:	2d 93       	st	X+, r18
     7b2:	3c 93       	st	X, r19
		if (v->MotorOut4 < LOWVALUE)
     7b4:	44 97       	sbiw	r24, 0x14	; 20
     7b6:	2c f4       	brge	.+10     	; 0x7c2 <computedata_motors+0x1be>
			v->MotorOut4 = LOWVALUE;	
     7b8:	84 e1       	ldi	r24, 0x14	; 20
     7ba:	90 e0       	ldi	r25, 0x00	; 0
     7bc:	f8 01       	movw	r30, r16
     7be:	91 83       	std	Z+1, r25	; 0x01
     7c0:	80 83       	st	Z, r24
}
     7c2:	df 91       	pop	r29
     7c4:	cf 91       	pop	r28
     7c6:	1f 91       	pop	r17
     7c8:	0f 91       	pop	r16
     7ca:	ff 90       	pop	r15
     7cc:	ef 90       	pop	r14
     7ce:	df 90       	pop	r13
     7d0:	cf 90       	pop	r12
     7d2:	bf 90       	pop	r11
     7d4:	af 90       	pop	r10
     7d6:	08 95       	ret

000007d8 <init_asserv_haut_pids>:
 *
 *  Initialise les variables pour le PID servant pour l'asservissement en hauteur
 *
 */
void init_asserv_haut_pids(){
	pid_Init(K_ALT_P * SCALING_FACTOR, K_ALT_I * SCALING_FACTOR, K_ALT_D * SCALING_FACTOR, &pidData_alt);
     7d8:	26 e5       	ldi	r18, 0x56	; 86
     7da:	32 e0       	ldi	r19, 0x02	; 2
     7dc:	40 e0       	ldi	r20, 0x00	; 0
     7de:	50 e0       	ldi	r21, 0x00	; 0
     7e0:	60 e0       	ldi	r22, 0x00	; 0
     7e2:	70 e0       	ldi	r23, 0x00	; 0
     7e4:	83 e3       	ldi	r24, 0x33	; 51
     7e6:	90 e0       	ldi	r25, 0x00	; 0
     7e8:	0c 94 f4 06 	jmp	0xde8	; 0xde8 <pid_Init>

000007ec <reset_asserv_haut_pids>:
 *
 *  Réinitialise les paramètres du PID
 *
 */
void reset_asserv_haut_pids(){
	pid_Reset_Integrator(&pidData_alt);	
     7ec:	86 e5       	ldi	r24, 0x56	; 86
     7ee:	92 e0       	ldi	r25, 0x02	; 2
     7f0:	0c 94 b6 07 	jmp	0xf6c	; 0xf6c <pid_Reset_Integrator>

000007f4 <asserv_alt>:
 *
 *  Algorithme d'asservissement en hauteur.
 *
 *  \param v  Structure de stockage des différentes valeurs.
 */
int asserv_alt(struct vars_t *v){
     7f4:	0f 93       	push	r16
     7f6:	1f 93       	push	r17
     7f8:	cf 93       	push	r28
     7fa:	df 93       	push	r29
	//Valeur la plus faible = 1615
	//Valeur max = 60 000
	//Valeur pour environ 1 m = 9000
	v->cons_alt = 9000;//Pour les tests ...
     7fc:	fc 01       	movw	r30, r24
     7fe:	ed 57       	subi	r30, 0x7D	; 125
     800:	ff 4f       	sbci	r31, 0xFF	; 255
     802:	c8 e2       	ldi	r28, 0x28	; 40
     804:	d3 e2       	ldi	r29, 0x23	; 35
     806:	d1 83       	std	Z+1, r29	; 0x01
     808:	c0 83       	st	Z, r28
	/**********************************************************************************/

	/* calcul de la vitesse du quadricoptere */
	//printf("v_alt = %d",v->alt);
	
	vit_actuelle = (v->alt - altitude_prec)/0.02;// * 50 / nb_20ms; // * 50 means / Te
     80a:	32 97       	sbiw	r30, 0x02	; 2
     80c:	00 81       	ld	r16, Z
     80e:	11 81       	ldd	r17, Z+1	; 0x01
     810:	80 91 16 02 	lds	r24, 0x0216	; 0x800216 <__data_end>
     814:	90 91 17 02 	lds	r25, 0x0217	; 0x800217 <__data_end+0x1>
     818:	b8 01       	movw	r22, r16
     81a:	68 1b       	sub	r22, r24
     81c:	79 0b       	sbc	r23, r25
     81e:	80 e0       	ldi	r24, 0x00	; 0
     820:	90 e0       	ldi	r25, 0x00	; 0
     822:	0e 94 42 09 	call	0x1284	; 0x1284 <__floatunsisf>
     826:	2a e0       	ldi	r18, 0x0A	; 10
     828:	37 ed       	ldi	r19, 0xD7	; 215
     82a:	43 ea       	ldi	r20, 0xA3	; 163
     82c:	5c e3       	ldi	r21, 0x3C	; 60
     82e:	0e 94 9a 08 	call	0x1134	; 0x1134 <__divsf3>
     832:	0e 94 0c 09 	call	0x1218	; 0x1218 <__fixsfsi>
	//printf("v_alt = %d, altitude_prec = %d , vit_actuelle = %d",v->alt, altitude_prec, vit_actuelle);
	altitude_prec = v->alt;
     836:	10 93 17 02 	sts	0x0217, r17	; 0x800217 <__data_end+0x1>
     83a:	00 93 16 02 	sts	0x0216, r16	; 0x800216 <__data_end>
	//printf("vit_act = %d, altitude_prec = %d", vit_actuelle,altitude_prec);

	/* calcul de l'erreur d'altitude et de la consigne de vitesse */
	erreur_alt = (v->cons_alt) - (v->alt);

	consigne_vit = erreur_alt / GAINVITESSE; // GainVitesse = 0.25
     83e:	9e 01       	movw	r18, r28
     840:	20 1b       	sub	r18, r16
     842:	31 0b       	sbc	r19, r17
     844:	37 ff       	sbrs	r19, 7
     846:	02 c0       	rjmp	.+4      	; 0x84c <asserv_alt+0x58>
     848:	2d 5f       	subi	r18, 0xFD	; 253
     84a:	3f 4f       	sbci	r19, 0xFF	; 255
     84c:	35 95       	asr	r19
     84e:	27 95       	ror	r18
     850:	35 95       	asr	r19
     852:	27 95       	ror	r18

	/* saturation de la consigne de vitesse */
	if(consigne_vit > VIT_MAX){
     854:	25 36       	cpi	r18, 0x65	; 101
     856:	31 05       	cpc	r19, r1
     858:	3c f4       	brge	.+14     	; 0x868 <asserv_alt+0x74>
		consigne_vit = VIT_MAX; // saturation max
	}

	if(consigne_vit < VIT_MIN ){
     85a:	25 3b       	cpi	r18, 0xB5	; 181
     85c:	4f ef       	ldi	r20, 0xFF	; 255
     85e:	34 07       	cpc	r19, r20
     860:	2c f4       	brge	.+10     	; 0x86c <asserv_alt+0x78>
		consigne_vit = VIT_MIN;  // saturation min
     862:	25 eb       	ldi	r18, 0xB5	; 181
     864:	3f ef       	ldi	r19, 0xFF	; 255
     866:	02 c0       	rjmp	.+4      	; 0x86c <asserv_alt+0x78>

	consigne_vit = erreur_alt / GAINVITESSE; // GainVitesse = 0.25

	/* saturation de la consigne de vitesse */
	if(consigne_vit > VIT_MAX){
		consigne_vit = VIT_MAX; // saturation max
     868:	24 e6       	ldi	r18, 0x64	; 100
     86a:	30 e0       	ldi	r19, 0x00	; 0
	if(consigne_vit < VIT_MIN ){
		consigne_vit = VIT_MIN;  // saturation min
	}

	/* calcul des coefficients du PID */
	col = pid_Controller(consigne_vit, vit_actuelle, &pidData_alt);
     86c:	46 e5       	ldi	r20, 0x56	; 86
     86e:	52 e0       	ldi	r21, 0x02	; 2
     870:	c9 01       	movw	r24, r18
     872:	0e 94 21 07 	call	0xe42	; 0xe42 <pid_Controller>

	/* saturation de la commande moteur */
	if(col > CMD_MOTEUR_MAX) {col = CMD_MOTEUR_MAX;} // saturation max
     876:	89 36       	cpi	r24, 0x69	; 105
     878:	21 e0       	ldi	r18, 0x01	; 1
     87a:	92 07       	cpc	r25, r18
     87c:	3c f4       	brge	.+14     	; 0x88c <asserv_alt+0x98>
	if(col < CMD_MOTEUR_MIN) {col = CMD_MOTEUR_MIN;} // saturation min
     87e:	80 31       	cpi	r24, 0x10	; 16
     880:	4f ef       	ldi	r20, 0xFF	; 255
     882:	94 07       	cpc	r25, r20
     884:	2c f4       	brge	.+10     	; 0x890 <asserv_alt+0x9c>
     886:	80 e1       	ldi	r24, 0x10	; 16
     888:	9f ef       	ldi	r25, 0xFF	; 255
     88a:	02 c0       	rjmp	.+4      	; 0x890 <asserv_alt+0x9c>

	/* calcul des coefficients du PID */
	col = pid_Controller(consigne_vit, vit_actuelle, &pidData_alt);

	/* saturation de la commande moteur */
	if(col > CMD_MOTEUR_MAX) {col = CMD_MOTEUR_MAX;} // saturation max
     88c:	88 e6       	ldi	r24, 0x68	; 104
     88e:	91 e0       	ldi	r25, 0x01	; 1

	/* Mutliplication du collectif par un gain d'accélération et ajout une commande nominale */
	col += CMD_MOTEUR_NOMINAL;//?
	
	return col;
}
     890:	84 5d       	subi	r24, 0xD4	; 212
     892:	9e 4f       	sbci	r25, 0xFE	; 254
     894:	df 91       	pop	r29
     896:	cf 91       	pop	r28
     898:	1f 91       	pop	r17
     89a:	0f 91       	pop	r16
     89c:	08 95       	ret

0000089e <init_usart_centrale>:
 volatile char val_attendues[7] = {0xFA, 0xFF, 0x36, 0x1E, 0, 0, 0x0C};		//structure message
 //Ces valeurs précède les données et sont les octets qui préçisent les types de données.
 
 int init_usart_centrale(void)
	 {
	 UBRR0H = 0;
     89e:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
	 UBRR0L = 8; // 115200 bauds
     8a2:	88 e0       	ldi	r24, 0x08	; 8
     8a4:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
	 
     RXIE permet de gérer les interruptions. 
     Tant que le microcontrôleur ne reçoit pas de données, le programme n'est pas bloqué et peut donc executer d'autre consigne.
     Lorsqu'il reçoit une donnée, le registre RXCIE permet de la détecter et d'exécuter une variable. 
	 */
	 UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);
     8a8:	86 e0       	ldi	r24, 0x06	; 6
     8aa:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
	 UCSR0B = (1<<RXEN0)|(1<<RXCIE0);
     8ae:	80 e9       	ldi	r24, 0x90	; 144
     8b0:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
	 /* Mode Asynchrone (RS232), Données de 8 bits, Bit de parité désactivé pour ne pas rajouté de bit à la trame qui est déjà codée sur 8 bits
	 */
	 
	 return(0);
	 }
     8b4:	80 e0       	ldi	r24, 0x00	; 0
     8b6:	90 e0       	ldi	r25, 0x00	; 0
     8b8:	08 95       	ret

000008ba <__vector_25>:


ISR(USART0_RX_vect){ //interruption
     8ba:	1f 92       	push	r1
     8bc:	0f 92       	push	r0
     8be:	0f b6       	in	r0, 0x3f	; 63
     8c0:	0f 92       	push	r0
     8c2:	11 24       	eor	r1, r1
     8c4:	0b b6       	in	r0, 0x3b	; 59
     8c6:	0f 92       	push	r0
     8c8:	2f 93       	push	r18
     8ca:	3f 93       	push	r19
     8cc:	4f 93       	push	r20
     8ce:	5f 93       	push	r21
     8d0:	6f 93       	push	r22
     8d2:	7f 93       	push	r23
     8d4:	8f 93       	push	r24
     8d6:	9f 93       	push	r25
     8d8:	ef 93       	push	r30
     8da:	ff 93       	push	r31
    	static int index_tab_result = 0; //place dans le tableau
    	static int type_result; //permet de stocker les valeurs de données (accélération 0x4031, l'Angle 0x2031...)
    	static int*tab_result; //permet de faire pointer "tab_result" vers le tableau "vitesse_angulaire[3]" ou "angls[3]" dans vars.h
    	static int receiving; //sert à stocker les données qu'on reçoit par UDR0
    	char c;
    	c = UDR0; //notre variable c va recevoir en entrée les donnée de UDR0
     8dc:	20 91 c6 00 	lds	r18, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
 
/*Les cas 0 à 6 sont les octets qui ne varient pas soit Preambule, Bid, Mid, Len, Checksum (cf cr 2015)*/
    	switch(etat){
     8e0:	80 91 20 02 	lds	r24, 0x0220	; 0x800220 <etat.1554>
     8e4:	90 91 21 02 	lds	r25, 0x0221	; 0x800221 <etat.1554+0x1>
     8e8:	82 32       	cpi	r24, 0x22	; 34
     8ea:	91 05       	cpc	r25, r1
     8ec:	08 f0       	brcs	.+2      	; 0x8f0 <__vector_25+0x36>
     8ee:	75 c0       	rjmp	.+234    	; 0x9da <__vector_25+0x120>
     8f0:	fc 01       	movw	r30, r24
     8f2:	ee 58       	subi	r30, 0x8E	; 142
     8f4:	ff 4f       	sbci	r31, 0xFF	; 255
     8f6:	0c 94 39 08 	jmp	0x1072	; 0x1072 <__tablejump2__>
           	case 0:
           	case 1:
           	case 2:
           	case 3:
           	case 6:
                   	if(c == val_attendues[etat]){ //on compare ce qu'on reçoit dans notre variable c à nos valeurs fixe, précisé dans "val_attendues[]"
     8fa:	fc 01       	movw	r30, r24
     8fc:	e2 5f       	subi	r30, 0xF2	; 242
     8fe:	fd 4f       	sbci	r31, 0xFD	; 253
     900:	30 81       	ld	r19, Z
     902:	23 17       	cp	r18, r19
     904:	09 f4       	brne	.+2      	; 0x908 <__vector_25+0x4e>
     906:	50 c0       	rjmp	.+160    	; 0x9a8 <__vector_25+0xee>
                           	etat++; // on incrémente l'état pour
                   	}
                   	else{
                           	etat = 0;
     908:	10 92 21 02 	sts	0x0221, r1	; 0x800221 <etat.1554+0x1>
     90c:	10 92 20 02 	sts	0x0220, r1	; 0x800220 <etat.1554>
     910:	64 c0       	rjmp	.+200    	; 0x9da <__vector_25+0x120>
                   	etat++;
                   	receiving=((int)c)<<8; // on décale ce qu'on reçoit de 8 bits vers la gauche (ex : on reçoit 0x20 on le place 8 bits à gauche)
                   	break;
           	case 5: //data ID (data reçues)
           	case 20: //data ID (data reçues)
                   	etat++;
     912:	01 96       	adiw	r24, 0x01	; 1
     914:	90 93 21 02 	sts	0x0221, r25	; 0x800221 <etat.1554+0x1>
     918:	80 93 20 02 	sts	0x0220, r24	; 0x800220 <etat.1554>
                   	type_result = receiving | ((int)c & 0xff);// on masque la donnée reçue (ex : on reçoit 0x31 on fait un masque (&) avec 0xFF pour  récupérer sa valeur et un masque (|=ou) avec le 0x20 reçu précédemment pour faire 0x2031 et le stocker dans type_result)
     91c:	80 91 1e 02 	lds	r24, 0x021E	; 0x80021e <receiving.1558>
     920:	90 91 1f 02 	lds	r25, 0x021F	; 0x80021f <receiving.1558+0x1>
     924:	82 2b       	or	r24, r18
     926:	90 93 1d 02 	sts	0x021D, r25	; 0x80021d <type_result.1556+0x1>
     92a:	80 93 1c 02 	sts	0x021C, r24	; 0x80021c <type_result.1556>
                   	switch (type_result) { //on test pour savoir dans lequel des deux cas on est avec la valeur dans type_result
     92e:	81 32       	cpi	r24, 0x21	; 33
     930:	20 e8       	ldi	r18, 0x80	; 128
     932:	92 07       	cpc	r25, r18
     934:	39 f0       	breq	.+14     	; 0x944 <__vector_25+0x8a>
     936:	81 33       	cpi	r24, 0x31	; 49
     938:	90 42       	sbci	r25, 0x20	; 32
     93a:	09 f0       	breq	.+2      	; 0x93e <__vector_25+0x84>
     93c:	4e c0       	rjmp	.+156    	; 0x9da <__vector_25+0x120>
                           	case 0x2031: //cas ou on reçoit l'angle
                                  	tab_result = angls; // on fait pointer tab_result vers le tableau "angls"
     93e:	84 e2       	ldi	r24, 0x24	; 36
     940:	92 e0       	ldi	r25, 0x02	; 2
     942:	02 c0       	rjmp	.+4      	; 0x948 <__vector_25+0x8e>
                                  	break;
                           	case 0x8021: //cas ou on reçoit la vitesse angulaire
                                  	tab_result = vitesse_angulaire; // on fait pointer tab_result vers le tableau "vitesse_angulaire"
     944:	82 e4       	ldi	r24, 0x42	; 66
     946:	92 e0       	ldi	r25, 0x02	; 2
     948:	90 93 1b 02 	sts	0x021B, r25	; 0x80021b <tab_result.1557+0x1>
     94c:	80 93 1a 02 	sts	0x021A, r24	; 0x80021a <tab_result.1557>
                                  	break;
     950:	44 c0       	rjmp	.+136    	; 0x9da <__vector_25+0x120>
           	case 11:
           	case 15:
           	case 22:
           	case 26:
           	case 30:
                   	etat++;
     952:	01 96       	adiw	r24, 0x01	; 1
     954:	90 93 21 02 	sts	0x0221, r25	; 0x800221 <etat.1554+0x1>
     958:	80 93 20 02 	sts	0x0220, r24	; 0x800220 <etat.1554>
                   	receiving=((int)c)<<8; //partie entière qu'on décale de 8 bits vers la droite pour laisser les 8 bits d'avant à la partie décimale
     95c:	10 92 1e 02 	sts	0x021E, r1	; 0x80021e <receiving.1558>
     960:	20 93 1f 02 	sts	0x021F, r18	; 0x80021f <receiving.1558+0x1>
                   	break;
     964:	3a c0       	rjmp	.+116    	; 0x9da <__vector_25+0x120>
           	case 12:
           	case 16:
           	case 23:
           	case 27:
           	case 31:
                   	etat++;
     966:	01 96       	adiw	r24, 0x01	; 1
     968:	90 93 21 02 	sts	0x0221, r25	; 0x800221 <etat.1554+0x1>
     96c:	80 93 20 02 	sts	0x0220, r24	; 0x800220 <etat.1554>
                   	tab_result[index_tab_result] = receiving|((int)c & 0xff); //partie décimale et partie entière sockée dans "tab_result[]".
     970:	80 91 18 02 	lds	r24, 0x0218	; 0x800218 <index_tab_result.1555>
     974:	90 91 19 02 	lds	r25, 0x0219	; 0x800219 <index_tab_result.1555+0x1>
     978:	ac 01       	movw	r20, r24
     97a:	44 0f       	add	r20, r20
     97c:	55 1f       	adc	r21, r21
     97e:	e0 91 1a 02 	lds	r30, 0x021A	; 0x80021a <tab_result.1557>
     982:	f0 91 1b 02 	lds	r31, 0x021B	; 0x80021b <tab_result.1557+0x1>
     986:	e4 0f       	add	r30, r20
     988:	f5 1f       	adc	r31, r21
     98a:	40 91 1e 02 	lds	r20, 0x021E	; 0x80021e <receiving.1558>
     98e:	50 91 1f 02 	lds	r21, 0x021F	; 0x80021f <receiving.1558+0x1>
     992:	ba 01       	movw	r22, r20
     994:	62 2b       	or	r22, r18
     996:	9b 01       	movw	r18, r22
     998:	31 83       	std	Z+1, r19	; 0x01
     99a:	20 83       	st	Z, r18
                   	index_tab_result++; //on incrémente "index_tab_result" pour stocker l'angle en x, y, z, l'accélération x, y z...
     99c:	01 96       	adiw	r24, 0x01	; 1
     99e:	90 93 19 02 	sts	0x0219, r25	; 0x800219 <index_tab_result.1555+0x1>
     9a2:	80 93 18 02 	sts	0x0218, r24	; 0x800218 <index_tab_result.1555>
                   	break;
     9a6:	19 c0       	rjmp	.+50     	; 0x9da <__vector_25+0x120>
    	    	case 24:
           	case 25:
           	case 28:
           	case 29:
           	case 32:
                   	etat++;//on incrémente état lors de ces case car nous n'utilisons pas les 2 derniers octets pour l'angles X, Y et Z (cf schématisation d'une trame)
     9a8:	01 96       	adiw	r24, 0x01	; 1
     9aa:	90 93 21 02 	sts	0x0221, r25	; 0x800221 <etat.1554+0x1>
     9ae:	80 93 20 02 	sts	0x0220, r24	; 0x800220 <etat.1554>
                   	break ;
     9b2:	13 c0       	rjmp	.+38     	; 0x9da <__vector_25+0x120>
                           	
           	case 21:
                   	if (c == val_attendues[6] ) { // si on est à 0x0C alors on incrémente état
     9b4:	80 91 14 02 	lds	r24, 0x0214	; 0x800214 <val_attendues+0x6>
     9b8:	28 13       	cpse	r18, r24
     9ba:	a6 cf       	rjmp	.-180    	; 0x908 <__vector_25+0x4e>
                           	etat++;
     9bc:	86 e1       	ldi	r24, 0x16	; 22
     9be:	90 e0       	ldi	r25, 0x00	; 0
     9c0:	90 93 21 02 	sts	0x0221, r25	; 0x800221 <etat.1554+0x1>
     9c4:	80 93 20 02 	sts	0x0220, r24	; 0x800220 <etat.1554>
     9c8:	04 c0       	rjmp	.+8      	; 0x9d2 <__vector_25+0x118>
                   	else {
                           	etat = 0; //sinon etat est remis à 0 et on reprend au début
                   	}
                   	break;
           	case 33:
                   	etat = 0;  // etat vaut 0 car on est à la fin de notre trame
     9ca:	10 92 21 02 	sts	0x0221, r1	; 0x800221 <etat.1554+0x1>
     9ce:	10 92 20 02 	sts	0x0220, r1	; 0x800220 <etat.1554>
                   	index_tab_result = 0; //et on remet index_tab_result à 0
     9d2:	10 92 19 02 	sts	0x0219, r1	; 0x800219 <index_tab_result.1555+0x1>
     9d6:	10 92 18 02 	sts	0x0218, r1	; 0x800218 <index_tab_result.1555>
                           	
    	} //
    		
    	
    	
} //
     9da:	ff 91       	pop	r31
     9dc:	ef 91       	pop	r30
     9de:	9f 91       	pop	r25
     9e0:	8f 91       	pop	r24
     9e2:	7f 91       	pop	r23
     9e4:	6f 91       	pop	r22
     9e6:	5f 91       	pop	r21
     9e8:	4f 91       	pop	r20
     9ea:	3f 91       	pop	r19
     9ec:	2f 91       	pop	r18
     9ee:	0f 90       	pop	r0
     9f0:	0b be       	out	0x3b, r0	; 59
     9f2:	0f 90       	pop	r0
     9f4:	0f be       	out	0x3f, r0	; 63
     9f6:	0f 90       	pop	r0
     9f8:	1f 90       	pop	r1
     9fa:	18 95       	reti

000009fc <centrale_read_gyro>:
	
	
void centrale_read_gyro(struct vars_t *v) {		
     9fc:	fc 01       	movw	r30, r24
	// X axis
	v->GyroX = -(vitesse_angulaire[1])*128;
     9fe:	a2 e4       	ldi	r26, 0x42	; 66
     a00:	b2 e0       	ldi	r27, 0x02	; 2
     a02:	12 96       	adiw	r26, 0x02	; 2
     a04:	4d 91       	ld	r20, X+
     a06:	5c 91       	ld	r21, X
     a08:	13 97       	sbiw	r26, 0x03	; 3
     a0a:	20 e8       	ldi	r18, 0x80	; 128
     a0c:	24 03       	mulsu	r18, r20
     a0e:	c0 01       	movw	r24, r0
     a10:	25 9f       	mul	r18, r21
     a12:	90 0d       	add	r25, r0
     a14:	11 24       	eor	r1, r1
     a16:	97 83       	std	Z+7, r25	; 0x07
     a18:	86 83       	std	Z+6, r24	; 0x06
	// Y axis
	v->GyroY = -(vitesse_angulaire[0])*128;
     a1a:	4d 91       	ld	r20, X+
     a1c:	5c 91       	ld	r21, X
     a1e:	11 97       	sbiw	r26, 0x01	; 1
     a20:	24 03       	mulsu	r18, r20
     a22:	c0 01       	movw	r24, r0
     a24:	25 9f       	mul	r18, r21
     a26:	90 0d       	add	r25, r0
     a28:	11 24       	eor	r1, r1
     a2a:	91 87       	std	Z+9, r25	; 0x09
     a2c:	80 87       	std	Z+8, r24	; 0x08
	// Z axis
	v->GyroZ = (vitesse_angulaire[2])*8;
     a2e:	14 96       	adiw	r26, 0x04	; 4
     a30:	8d 91       	ld	r24, X+
     a32:	9c 91       	ld	r25, X
     a34:	15 97       	sbiw	r26, 0x05	; 5
     a36:	23 e0       	ldi	r18, 0x03	; 3
     a38:	88 0f       	add	r24, r24
     a3a:	99 1f       	adc	r25, r25
     a3c:	2a 95       	dec	r18
     a3e:	e1 f7       	brne	.-8      	; 0xa38 <centrale_read_gyro+0x3c>
     a40:	93 87       	std	Z+11, r25	; 0x0b
     a42:	82 87       	std	Z+10, r24	; 0x0a
     a44:	08 95       	ret

00000a46 <centrale_read_angls>:
}

void centrale_read_angls(struct vars_t *v) {
     a46:	fc 01       	movw	r30, r24
	// X axis
	v->AngleY = -(angls[0])*2;		//2 pour 30°	//tangage
     a48:	a4 e2       	ldi	r26, 0x24	; 36
     a4a:	b2 e0       	ldi	r27, 0x02	; 2
     a4c:	8d 91       	ld	r24, X+
     a4e:	9c 91       	ld	r25, X
     a50:	11 97       	sbiw	r26, 0x01	; 1
     a52:	20 e0       	ldi	r18, 0x00	; 0
     a54:	30 e0       	ldi	r19, 0x00	; 0
     a56:	a9 01       	movw	r20, r18
     a58:	48 1b       	sub	r20, r24
     a5a:	59 0b       	sbc	r21, r25
     a5c:	ca 01       	movw	r24, r20
     a5e:	88 0f       	add	r24, r24
     a60:	99 1f       	adc	r25, r25
     a62:	97 87       	std	Z+15, r25	; 0x0f
     a64:	86 87       	std	Z+14, r24	; 0x0e
	// Y axis
	v->AngleX = -(angls[1])*2;		//roulis
     a66:	12 96       	adiw	r26, 0x02	; 2
     a68:	8d 91       	ld	r24, X+
     a6a:	9c 91       	ld	r25, X
     a6c:	13 97       	sbiw	r26, 0x03	; 3
     a6e:	28 1b       	sub	r18, r24
     a70:	39 0b       	sbc	r19, r25
     a72:	22 0f       	add	r18, r18
     a74:	33 1f       	adc	r19, r19
     a76:	35 87       	std	Z+13, r19	; 0x0d
     a78:	24 87       	std	Z+12, r18	; 0x0c
	// Z axis
	v->AngleZ = (angls[2])*2;		//lacet
     a7a:	14 96       	adiw	r26, 0x04	; 4
     a7c:	8d 91       	ld	r24, X+
     a7e:	9c 91       	ld	r25, X
     a80:	15 97       	sbiw	r26, 0x05	; 5
     a82:	88 0f       	add	r24, r24
     a84:	99 1f       	adc	r25, r25
     a86:	91 8b       	std	Z+17, r25	; 0x11
     a88:	80 8b       	std	Z+16, r24	; 0x10
     a8a:	08 95       	ret

00000a8c <init_interruptions>:
void init_interruptions(){
	//INT7 is used for the telecomande
	//INT6 is used for the sonar
	//INT0 for the voltmeter

	EICRB = (1<<ISC61)|(1<<ISC71);  // Falling Edge for INT7 and for INT6 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
     a8c:	80 ea       	ldi	r24, 0xA0	; 160
     a8e:	80 93 6a 00 	sts	0x006A, r24	; 0x80006a <__TEXT_REGION_LENGTH__+0x7e006a>
	EIMSK = (1<<INT6)|(1<<INT7);    // Autorisation des interruption(s) (INT1 et) INT0 (p72)														*/
     a92:	80 ec       	ldi	r24, 0xC0	; 192
     a94:	8d bb       	out	0x1d, r24	; 29

    PCICR = (1<<PCIE0); //Enable interrupt PCINT(0-7), any logical change
     a96:	81 e0       	ldi	r24, 0x01	; 1
     a98:	80 93 68 00 	sts	0x0068, r24	; 0x800068 <__TEXT_REGION_LENGTH__+0x7e0068>
    PCMSK0 = (1<<PCINT0); //Enable interrupt on PCINT0
     a9c:	80 93 6b 00 	sts	0x006B, r24	; 0x80006b <__TEXT_REGION_LENGTH__+0x7e006b>

	sei(); // validation globale des interruptions
     aa0:	78 94       	sei
     aa2:	08 95       	ret

00000aa4 <__vector_7>:



// Interruption capteur ultrason
ISR(INT6_vect)
{
     aa4:	1f 92       	push	r1
     aa6:	0f 92       	push	r0
     aa8:	0f b6       	in	r0, 0x3f	; 63
     aaa:	0f 92       	push	r0
     aac:	11 24       	eor	r1, r1
     aae:	2f 93       	push	r18
     ab0:	3f 93       	push	r19
     ab2:	8f 93       	push	r24
     ab4:	9f 93       	push	r25
	val_timer1 = diz_timer1*65536 + TCNT1;
     ab6:	80 91 4a 02 	lds	r24, 0x024A	; 0x80024a <diz_timer1>
     aba:	90 91 4b 02 	lds	r25, 0x024B	; 0x80024b <diz_timer1+0x1>
     abe:	80 91 84 00 	lds	r24, 0x0084	; 0x800084 <__TEXT_REGION_LENGTH__+0x7e0084>
     ac2:	90 91 85 00 	lds	r25, 0x0085	; 0x800085 <__TEXT_REGION_LENGTH__+0x7e0085>
     ac6:	90 93 49 02 	sts	0x0249, r25	; 0x800249 <val_timer1+0x1>
     aca:	80 93 48 02 	sts	0x0248, r24	; 0x800248 <val_timer1>
	
	if (PINE&(1<<PINE6)) { //rising
     ace:	66 9b       	sbis	0x0c, 6	; 12
     ad0:	09 c0       	rjmp	.+18     	; 0xae4 <__vector_7+0x40>
		front_montant_US = val_timer1;
     ad2:	80 91 48 02 	lds	r24, 0x0248	; 0x800248 <val_timer1>
     ad6:	90 91 49 02 	lds	r25, 0x0249	; 0x800249 <val_timer1+0x1>
     ada:	90 93 2b 02 	sts	0x022B, r25	; 0x80022b <front_montant_US+0x1>
     ade:	80 93 2a 02 	sts	0x022A, r24	; 0x80022a <front_montant_US>
     ae2:	0e c0       	rjmp	.+28     	; 0xb00 <__vector_7+0x5c>
	}
	else { //falling
		temps_etat_haut_US = (val_timer1 - front_montant_US); // / 2;
     ae4:	80 91 48 02 	lds	r24, 0x0248	; 0x800248 <val_timer1>
     ae8:	90 91 49 02 	lds	r25, 0x0249	; 0x800249 <val_timer1+0x1>
     aec:	20 91 2a 02 	lds	r18, 0x022A	; 0x80022a <front_montant_US>
     af0:	30 91 2b 02 	lds	r19, 0x022B	; 0x80022b <front_montant_US+0x1>
     af4:	82 1b       	sub	r24, r18
     af6:	93 0b       	sbc	r25, r19
     af8:	90 93 41 02 	sts	0x0241, r25	; 0x800241 <temps_etat_haut_US+0x1>
     afc:	80 93 40 02 	sts	0x0240, r24	; 0x800240 <temps_etat_haut_US>
	}

}
     b00:	9f 91       	pop	r25
     b02:	8f 91       	pop	r24
     b04:	3f 91       	pop	r19
     b06:	2f 91       	pop	r18
     b08:	0f 90       	pop	r0
     b0a:	0f be       	out	0x3f, r0	; 63
     b0c:	0f 90       	pop	r0
     b0e:	1f 90       	pop	r1
     b10:	18 95       	reti

00000b12 <__vector_20>:

// interruption pour scruter le gyro et récuperer les données à traiter

ISR( TIMER1_OVF_vect ){ //Timer 1
     b12:	1f 92       	push	r1
     b14:	0f 92       	push	r0
     b16:	0f b6       	in	r0, 0x3f	; 63
     b18:	0f 92       	push	r0
     b1a:	11 24       	eor	r1, r1
     b1c:	8f 93       	push	r24
     b1e:	9f 93       	push	r25
	diz_timer1++;
     b20:	80 91 4a 02 	lds	r24, 0x024A	; 0x80024a <diz_timer1>
     b24:	90 91 4b 02 	lds	r25, 0x024B	; 0x80024b <diz_timer1+0x1>
     b28:	01 96       	adiw	r24, 0x01	; 1
     b2a:	90 93 4b 02 	sts	0x024B, r25	; 0x80024b <diz_timer1+0x1>
     b2e:	80 93 4a 02 	sts	0x024A, r24	; 0x80024a <diz_timer1>
}
     b32:	9f 91       	pop	r25
     b34:	8f 91       	pop	r24
     b36:	0f 90       	pop	r0
     b38:	0f be       	out	0x3f, r0	; 63
     b3a:	0f 90       	pop	r0
     b3c:	1f 90       	pop	r1
     b3e:	18 95       	reti

00000b40 <__vector_32>:

ISR( TIMER3_COMPA_vect ){//Timer 0 - Sert aussi à définir Te (Fréquence d'échantillonage)
     b40:	1f 92       	push	r1
     b42:	0f 92       	push	r0
     b44:	0f b6       	in	r0, 0x3f	; 63
     b46:	0f 92       	push	r0
     b48:	11 24       	eor	r1, r1
     b4a:	8f 93       	push	r24
     b4c:	9f 93       	push	r25
	flag_asser = 1;
     b4e:	81 e0       	ldi	r24, 0x01	; 1
     b50:	90 e0       	ldi	r25, 0x00	; 0
     b52:	90 93 4d 02 	sts	0x024D, r25	; 0x80024d <flag_asser+0x1>
     b56:	80 93 4c 02 	sts	0x024C, r24	; 0x80024c <flag_asser>
}
     b5a:	9f 91       	pop	r25
     b5c:	8f 91       	pop	r24
     b5e:	0f 90       	pop	r0
     b60:	0f be       	out	0x3f, r0	; 63
     b62:	0f 90       	pop	r0
     b64:	1f 90       	pop	r1
     b66:	18 95       	reti

00000b68 <__vector_9>:

ISR(PCINT0_vect){
     b68:	1f 92       	push	r1
     b6a:	0f 92       	push	r0
     b6c:	0f b6       	in	r0, 0x3f	; 63
     b6e:	0f 92       	push	r0
     b70:	11 24       	eor	r1, r1
     b72:	0f 93       	push	r16
     b74:	1f 93       	push	r17
     b76:	2f 93       	push	r18
     b78:	3f 93       	push	r19
     b7a:	4f 93       	push	r20
     b7c:	5f 93       	push	r21
     b7e:	6f 93       	push	r22
     b80:	7f 93       	push	r23
     b82:	8f 93       	push	r24
     b84:	9f 93       	push	r25
     b86:	af 93       	push	r26
     b88:	bf 93       	push	r27
	unsigned long int temp;
	if ( (PINB&(1<<PINB0)) == 0) {
     b8a:	18 99       	sbic	0x03, 0	; 3
     b8c:	37 c0       	rjmp	.+110    	; 0xbfc <__vector_9+0x94>
		temp = TCNT1 + ((unsigned long int)diz_timer1 << 16);
     b8e:	20 91 84 00 	lds	r18, 0x0084	; 0x800084 <__TEXT_REGION_LENGTH__+0x7e0084>
     b92:	30 91 85 00 	lds	r19, 0x0085	; 0x800085 <__TEXT_REGION_LENGTH__+0x7e0085>
     b96:	80 91 4a 02 	lds	r24, 0x024A	; 0x80024a <diz_timer1>
     b9a:	90 91 4b 02 	lds	r25, 0x024B	; 0x80024b <diz_timer1+0x1>
     b9e:	a0 e0       	ldi	r26, 0x00	; 0
     ba0:	b0 e0       	ldi	r27, 0x00	; 0
     ba2:	dc 01       	movw	r26, r24
     ba4:	99 27       	eor	r25, r25
     ba6:	88 27       	eor	r24, r24
     ba8:	82 0f       	add	r24, r18
     baa:	93 1f       	adc	r25, r19
     bac:	a1 1d       	adc	r26, r1
     bae:	b1 1d       	adc	r27, r1
		//printf("t%lu ", temp);
		diff_volt = (temp - last_value_volt)/2;
     bb0:	40 91 52 02 	lds	r20, 0x0252	; 0x800252 <last_value_volt>
     bb4:	50 91 53 02 	lds	r21, 0x0253	; 0x800253 <last_value_volt+0x1>
     bb8:	60 91 54 02 	lds	r22, 0x0254	; 0x800254 <last_value_volt+0x2>
     bbc:	70 91 55 02 	lds	r23, 0x0255	; 0x800255 <last_value_volt+0x3>
     bc0:	8c 01       	movw	r16, r24
     bc2:	9d 01       	movw	r18, r26
     bc4:	04 1b       	sub	r16, r20
     bc6:	15 0b       	sbc	r17, r21
     bc8:	26 0b       	sbc	r18, r22
     bca:	37 0b       	sbc	r19, r23
     bcc:	b9 01       	movw	r22, r18
     bce:	a8 01       	movw	r20, r16
     bd0:	76 95       	lsr	r23
     bd2:	67 95       	ror	r22
     bd4:	57 95       	ror	r21
     bd6:	47 95       	ror	r20
     bd8:	50 93 69 02 	sts	0x0269, r21	; 0x800269 <diff_volt+0x1>
     bdc:	40 93 68 02 	sts	0x0268, r20	; 0x800268 <diff_volt>
		last_value_volt = temp;
     be0:	80 93 52 02 	sts	0x0252, r24	; 0x800252 <last_value_volt>
     be4:	90 93 53 02 	sts	0x0253, r25	; 0x800253 <last_value_volt+0x1>
     be8:	a0 93 54 02 	sts	0x0254, r26	; 0x800254 <last_value_volt+0x2>
     bec:	b0 93 55 02 	sts	0x0255, r27	; 0x800255 <last_value_volt+0x3>
		flag_int_volt = 1;
     bf0:	81 e0       	ldi	r24, 0x01	; 1
     bf2:	90 e0       	ldi	r25, 0x00	; 0
     bf4:	90 93 74 02 	sts	0x0274, r25	; 0x800274 <flag_int_volt+0x1>
     bf8:	80 93 73 02 	sts	0x0273, r24	; 0x800273 <flag_int_volt>
	}
     bfc:	bf 91       	pop	r27
     bfe:	af 91       	pop	r26
     c00:	9f 91       	pop	r25
     c02:	8f 91       	pop	r24
     c04:	7f 91       	pop	r23
     c06:	6f 91       	pop	r22
     c08:	5f 91       	pop	r21
     c0a:	4f 91       	pop	r20
     c0c:	3f 91       	pop	r19
     c0e:	2f 91       	pop	r18
     c10:	1f 91       	pop	r17
     c12:	0f 91       	pop	r16
     c14:	0f 90       	pop	r0
     c16:	0f be       	out	0x3f, r0	; 63
     c18:	0f 90       	pop	r0
     c1a:	1f 90       	pop	r1
     c1c:	18 95       	reti

00000c1e <main>:
    //To use printf and getchar ...
//	stdout=&uart_str;
	//stdin=&uart_str;

    //INIT all function :
	init_port();
     c1e:	0e 94 e7 00 	call	0x1ce	; 0x1ce <init_port>
	init_interruptions ();
     c22:	0e 94 46 05 	call	0xa8c	; 0xa8c <init_interruptions>
	init_uart();
     c26:	0e 94 ce 00 	call	0x19c	; 0x19c <init_uart>
	init_usart_centrale();
     c2a:	0e 94 4f 04 	call	0x89e	; 0x89e <init_usart_centrale>
	
	init_vars(&v);
     c2e:	83 ee       	ldi	r24, 0xE3	; 227
     c30:	92 e0       	ldi	r25, 0x02	; 2
     c32:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <init_vars>
//	gyros_init();
	//accels_init();
	init_timer1();
     c36:	0e 94 ed 07 	call	0xfda	; 0xfda <init_timer1>
	init_timer3();
     c3a:	0e 94 f7 07 	call	0xfee	; 0xfee <init_timer3>
	init_pwm_m();
     c3e:	0e 94 bc 07 	call	0xf78	; 0xf78 <init_pwm_m>
	
	init_motors_pids();
     c42:	0e 94 ae 02 	call	0x55c	; 0x55c <init_motors_pids>
	
	init_asserv_haut_pids();//Fonction d'initialisation sur l'asservissement en hauteur
     c46:	0e 94 ec 03 	call	0x7d8	; 0x7d8 <init_asserv_haut_pids>
	
	reset_asserv_haut_pids();//Fonction de reset
     c4a:	0e 94 f6 03 	call	0x7ec	; 0x7ec <reset_asserv_haut_pids>
	
	//printf("printf success ! \n");

	//v.FlagArmed = 0;
	v.cpt_asser = 0;
     c4e:	10 92 6b 03 	sts	0x036B, r1	; 0x80036b <v+0x88>
     c52:	10 92 6a 03 	sts	0x036A, r1	; 0x80036a <v+0x87>
		v.RxChannels[1] = 0;
		v.RxChannels[2] = 0;
		v.RxChannels[3] = 0;*/
	

		ConvertRxChannels(&v);
     c56:	83 ee       	ldi	r24, 0xE3	; 227
     c58:	92 e0       	ldi	r25, 0x02	; 2
     c5a:	0e 94 fe 00 	call	0x1fc	; 0x1fc <ConvertRxChannels>

		//v.FlagArmed = 0;
		//v.AsserHaut = 0;

		//gyros_read_values_raw_cal(&v);
		centrale_read_angls(&v);
     c5e:	83 ee       	ldi	r24, 0xE3	; 227
     c60:	92 e0       	ldi	r25, 0x02	; 2
     c62:	0e 94 23 05 	call	0xa46	; 0xa46 <centrale_read_angls>
		centrale_read_gyro(&v);	
     c66:	83 ee       	ldi	r24, 0xE3	; 227
     c68:	92 e0       	ldi	r25, 0x02	; 2
     c6a:	0e 94 fe 04 	call	0x9fc	; 0x9fc <centrale_read_gyro>
		else {
			reset_led1();
		}*/
		
		//printf("Boucle\n");		
		if (v.FlagArmed == 1){//Si le module est armé
     c6e:	80 91 5a 03 	lds	r24, 0x035A	; 0x80035a <v+0x77>
     c72:	90 91 5b 03 	lds	r25, 0x035B	; 0x80035b <v+0x78>
     c76:	01 97       	sbiw	r24, 0x01	; 1
     c78:	71 f7       	brne	.-36     	; 0xc56 <main+0x38>
			if (v.FlagCollectiveZero == 1){
     c7a:	80 91 31 03 	lds	r24, 0x0331	; 0x800331 <v+0x4e>
     c7e:	81 30       	cpi	r24, 0x01	; 1
     c80:	61 f4       	brne	.+24     	; 0xc9a <main+0x7c>
				v.computedCollective = 0;
     c82:	10 92 55 03 	sts	0x0355, r1	; 0x800355 <v+0x72>
     c86:	10 92 54 03 	sts	0x0354, r1	; 0x800354 <v+0x71>
				init_motors_pids();
     c8a:	0e 94 ae 02 	call	0x55c	; 0x55c <init_motors_pids>
				init_asserv_haut_pids();
     c8e:	0e 94 ec 03 	call	0x7d8	; 0x7d8 <init_asserv_haut_pids>

				reset_motors_pids();
     c92:	0e 94 ea 02 	call	0x5d4	; 0x5d4 <reset_motors_pids>
				reset_asserv_haut_pids();
     c96:	0e 94 f6 03 	call	0x7ec	; 0x7ec <reset_asserv_haut_pids>
			}
			
			if (flag_asser==1) {
     c9a:	80 91 4c 02 	lds	r24, 0x024C	; 0x80024c <flag_asser>
     c9e:	90 91 4d 02 	lds	r25, 0x024D	; 0x80024d <flag_asser+0x1>
     ca2:	01 97       	sbiw	r24, 0x01	; 1
     ca4:	c1 f6       	brne	.-80     	; 0xc56 <main+0x38>
				v.cpt_asser++;
     ca6:	80 91 6a 03 	lds	r24, 0x036A	; 0x80036a <v+0x87>
     caa:	90 91 6b 03 	lds	r25, 0x036B	; 0x80036b <v+0x88>
     cae:	01 96       	adiw	r24, 0x01	; 1
     cb0:	90 93 6b 03 	sts	0x036B, r25	; 0x80036b <v+0x88>
     cb4:	80 93 6a 03 	sts	0x036A, r24	; 0x80036a <v+0x87>
				if (v.AsserHaut == 1){
     cb8:	20 91 68 03 	lds	r18, 0x0368	; 0x800368 <v+0x85>
     cbc:	30 91 69 03 	lds	r19, 0x0369	; 0x800369 <v+0x86>
     cc0:	21 30       	cpi	r18, 0x01	; 1
     cc2:	31 05       	cpc	r19, r1
     cc4:	79 f4       	brne	.+30     	; 0xce4 <main+0xc6>
					if (v.cpt_asser >= 5){
     cc6:	05 97       	sbiw	r24, 0x05	; 5
     cc8:	bc f0       	brlt	.+46     	; 0xcf8 <main+0xda>
						//set_led2();
						v.computedCollective = asserv_alt(&v);
     cca:	83 ee       	ldi	r24, 0xE3	; 227
     ccc:	92 e0       	ldi	r25, 0x02	; 2
     cce:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <asserv_alt>
     cd2:	90 93 55 03 	sts	0x0355, r25	; 0x800355 <v+0x72>
     cd6:	80 93 54 03 	sts	0x0354, r24	; 0x800354 <v+0x71>
						//printf("cpt_asser \n");
						v.cpt_asser = 0;
     cda:	10 92 6b 03 	sts	0x036B, r1	; 0x80036b <v+0x88>
     cde:	10 92 6a 03 	sts	0x036A, r1	; 0x80036a <v+0x87>
     ce2:	0a c0       	rjmp	.+20     	; 0xcf8 <main+0xda>
				//printf("printf de partout \n");
						}
				}
				else {
					v.computedCollective = v.RxInCollective;
     ce4:	80 91 4c 03 	lds	r24, 0x034C	; 0x80034c <v+0x69>
     ce8:	90 91 4d 03 	lds	r25, 0x034D	; 0x80034d <v+0x6a>
     cec:	90 93 55 03 	sts	0x0355, r25	; 0x800355 <v+0x72>
     cf0:	80 93 54 03 	sts	0x0354, r24	; 0x800354 <v+0x71>
					reset_led2();
     cf4:	0e 94 e1 00 	call	0x1c2	; 0x1c2 <reset_led2>
					//printf("ICI 2 \n");
				}
				
				computedata_motors(&v);
     cf8:	83 ee       	ldi	r24, 0xE3	; 227
     cfa:	92 e0       	ldi	r25, 0x02	; 2
     cfc:	0e 94 02 03 	call	0x604	; 0x604 <computedata_motors>
				output_motors(&v);
     d00:	83 ee       	ldi	r24, 0xE3	; 227
     d02:	92 e0       	ldi	r25, 0x02	; 2
     d04:	0e 94 10 02 	call	0x420	; 0x420 <output_motors>
		
				//rajouter camera
				//printf("MotorOut1 : %d \n", v.MotorOut1);
				
				flag_asser = 0;//Pour le prochain passage
     d08:	10 92 4d 02 	sts	0x024D, r1	; 0x80024d <flag_asser+0x1>
     d0c:	10 92 4c 02 	sts	0x024C, r1	; 0x80024c <flag_asser>
     d10:	a2 cf       	rjmp	.-188    	; 0xc56 <main+0x38>

00000d12 <__vector_8>:
	return 0;
}

//Interruption telecommande
ISR( INT7_vect )
{
     d12:	1f 92       	push	r1
     d14:	0f 92       	push	r0
     d16:	0f b6       	in	r0, 0x3f	; 63
     d18:	0f 92       	push	r0
     d1a:	11 24       	eor	r1, r1
     d1c:	0b b6       	in	r0, 0x3b	; 59
     d1e:	0f 92       	push	r0
     d20:	2f 93       	push	r18
     d22:	3f 93       	push	r19
     d24:	4f 93       	push	r20
     d26:	5f 93       	push	r21
     d28:	6f 93       	push	r22
     d2a:	7f 93       	push	r23
     d2c:	8f 93       	push	r24
     d2e:	9f 93       	push	r25
     d30:	ef 93       	push	r30
     d32:	ff 93       	push	r31
	static int i_PPM=0;
	int val_temp;

	val_temp = TCNT1;
     d34:	60 91 84 00 	lds	r22, 0x0084	; 0x800084 <__TEXT_REGION_LENGTH__+0x7e0084>
     d38:	70 91 85 00 	lds	r23, 0x0085	; 0x800085 <__TEXT_REGION_LENGTH__+0x7e0085>

	// Ici TCNT1 contient la valeur courante de TCNT1 sur Front Descendant de la PPM1 :
	v.RxChannels[i_PPM] = (val_temp - val_TCNT1_fd_PPM) >> 1;
     d3c:	20 91 22 02 	lds	r18, 0x0222	; 0x800222 <i_PPM.2528>
     d40:	30 91 23 02 	lds	r19, 0x0223	; 0x800223 <i_PPM.2528+0x1>
     d44:	80 91 4e 02 	lds	r24, 0x024E	; 0x80024e <val_TCNT1_fd_PPM>
     d48:	90 91 4f 02 	lds	r25, 0x024F	; 0x80024f <val_TCNT1_fd_PPM+0x1>
     d4c:	ab 01       	movw	r20, r22
     d4e:	48 1b       	sub	r20, r24
     d50:	59 0b       	sbc	r21, r25
     d52:	ca 01       	movw	r24, r20
     d54:	95 95       	asr	r25
     d56:	87 95       	ror	r24
     d58:	a9 01       	movw	r20, r18
     d5a:	44 0f       	add	r20, r20
     d5c:	55 1f       	adc	r21, r21
     d5e:	fa 01       	movw	r30, r20
     d60:	ec 5c       	subi	r30, 0xCC	; 204
     d62:	fc 4f       	sbci	r31, 0xFC	; 252
     d64:	91 83       	std	Z+1, r25	; 0x01
     d66:	80 83       	st	Z, r24
	if (i_PPM == 0) {
     d68:	21 15       	cp	r18, r1
     d6a:	31 05       	cpc	r19, r1
     d6c:	71 f4       	brne	.+28     	; 0xd8a <__vector_8+0x78>
		v.RxChannels[i_PPM] -= 1100;
     d6e:	8c 54       	subi	r24, 0x4C	; 76
     d70:	94 40       	sbci	r25, 0x04	; 4
		if (v.RxChannels[i_PPM] < 0)
     d72:	97 fd       	sbrc	r25, 7
     d74:	05 c0       	rjmp	.+10     	; 0xd80 <__vector_8+0x6e>
	val_temp = TCNT1;

	// Ici TCNT1 contient la valeur courante de TCNT1 sur Front Descendant de la PPM1 :
	v.RxChannels[i_PPM] = (val_temp - val_TCNT1_fd_PPM) >> 1;
	if (i_PPM == 0) {
		v.RxChannels[i_PPM] -= 1100;
     d76:	90 93 35 03 	sts	0x0335, r25	; 0x800335 <v+0x52>
     d7a:	80 93 34 03 	sts	0x0334, r24	; 0x800334 <v+0x51>
     d7e:	0c c0       	rjmp	.+24     	; 0xd98 <__vector_8+0x86>
		if (v.RxChannels[i_PPM] < 0)
			v.RxChannels[i_PPM] = 0;
     d80:	10 92 35 03 	sts	0x0335, r1	; 0x800335 <v+0x52>
     d84:	10 92 34 03 	sts	0x0334, r1	; 0x800334 <v+0x51>
     d88:	07 c0       	rjmp	.+14     	; 0xd98 <__vector_8+0x86>
	}
	else if (i_PPM < 8) {
     d8a:	28 30       	cpi	r18, 0x08	; 8
     d8c:	31 05       	cpc	r19, r1
     d8e:	24 f4       	brge	.+8      	; 0xd98 <__vector_8+0x86>
		v.RxChannels[i_PPM] -= 1500;
     d90:	8c 5d       	subi	r24, 0xDC	; 220
     d92:	95 40       	sbci	r25, 0x05	; 5
     d94:	91 83       	std	Z+1, r25	; 0x01
     d96:	80 83       	st	Z, r24
	}
	val_TCNT1_fd_PPM = val_temp;
     d98:	70 93 4f 02 	sts	0x024F, r23	; 0x80024f <val_TCNT1_fd_PPM+0x1>
     d9c:	60 93 4e 02 	sts	0x024E, r22	; 0x80024e <val_TCNT1_fd_PPM>

	if (v.RxChannels[i_PPM]> 4000){ // pour 4ms<->4000
     da0:	fa 01       	movw	r30, r20
     da2:	ec 5c       	subi	r30, 0xCC	; 204
     da4:	fc 4f       	sbci	r31, 0xFC	; 252
     da6:	80 81       	ld	r24, Z
     da8:	91 81       	ldd	r25, Z+1	; 0x01
     daa:	81 3a       	cpi	r24, 0xA1	; 161
     dac:	9f 40       	sbci	r25, 0x0F	; 15
     dae:	2c f0       	brlt	.+10     	; 0xdba <__vector_8+0xa8>
		i_PPM=0;
     db0:	10 92 23 02 	sts	0x0223, r1	; 0x800223 <i_PPM.2528+0x1>
     db4:	10 92 22 02 	sts	0x0222, r1	; 0x800222 <i_PPM.2528>
     db8:	06 c0       	rjmp	.+12     	; 0xdc6 <__vector_8+0xb4>
	}
	else{
		i_PPM++;
     dba:	2f 5f       	subi	r18, 0xFF	; 255
     dbc:	3f 4f       	sbci	r19, 0xFF	; 255
     dbe:	30 93 23 02 	sts	0x0223, r19	; 0x800223 <i_PPM.2528+0x1>
     dc2:	20 93 22 02 	sts	0x0222, r18	; 0x800222 <i_PPM.2528>
	}
}
     dc6:	ff 91       	pop	r31
     dc8:	ef 91       	pop	r30
     dca:	9f 91       	pop	r25
     dcc:	8f 91       	pop	r24
     dce:	7f 91       	pop	r23
     dd0:	6f 91       	pop	r22
     dd2:	5f 91       	pop	r21
     dd4:	4f 91       	pop	r20
     dd6:	3f 91       	pop	r19
     dd8:	2f 91       	pop	r18
     dda:	0f 90       	pop	r0
     ddc:	0b be       	out	0x3b, r0	; 59
     dde:	0f 90       	pop	r0
     de0:	0f be       	out	0x3f, r0	; 63
     de2:	0f 90       	pop	r0
     de4:	1f 90       	pop	r1
     de6:	18 95       	reti

00000de8 <pid_Init>:
 *  \param d_factor  Derivate term.
 *  \param pid  Struct with PID status.
 */
void pid_Init(int16_t p_factor, int16_t i_factor, int16_t d_factor, struct PID_DATA *pid)
// Set up PID controller parameters
{
     de8:	cf 93       	push	r28
     dea:	df 93       	push	r29
     dec:	fb 01       	movw	r30, r22
     dee:	e9 01       	movw	r28, r18
  // Start values for PID controller
  pid->sumError = 0;
     df0:	1a 82       	std	Y+2, r1	; 0x02
     df2:	1b 82       	std	Y+3, r1	; 0x03
     df4:	1c 82       	std	Y+4, r1	; 0x04
     df6:	1d 82       	std	Y+5, r1	; 0x05
  pid->lastProcessValue = 0;
     df8:	19 82       	std	Y+1, r1	; 0x01
     dfa:	18 82       	st	Y, r1
  // Tuning constants for PID loop
  pid->P_Factor = p_factor;
     dfc:	9f 83       	std	Y+7, r25	; 0x07
     dfe:	8e 83       	std	Y+6, r24	; 0x06
  pid->I_Factor = i_factor;
     e00:	79 87       	std	Y+9, r23	; 0x09
     e02:	68 87       	std	Y+8, r22	; 0x08
  pid->D_Factor = d_factor;
     e04:	5b 87       	std	Y+11, r21	; 0x0b
     e06:	4a 87       	std	Y+10, r20	; 0x0a
  // Limits to avoid overflow
  pid->maxError = MAX_INT / (pid->P_Factor + 1);
     e08:	bc 01       	movw	r22, r24
     e0a:	6f 5f       	subi	r22, 0xFF	; 255
     e0c:	7f 4f       	sbci	r23, 0xFF	; 255
     e0e:	8f ef       	ldi	r24, 0xFF	; 255
     e10:	9f e7       	ldi	r25, 0x7F	; 127
     e12:	0e 94 06 08 	call	0x100c	; 0x100c <__divmodhi4>
     e16:	7d 87       	std	Y+13, r23	; 0x0d
     e18:	6c 87       	std	Y+12, r22	; 0x0c
  pid->maxSumError = MAX_I_TERM / (pid->I_Factor + 1);
     e1a:	9f 01       	movw	r18, r30
     e1c:	2f 5f       	subi	r18, 0xFF	; 255
     e1e:	3f 4f       	sbci	r19, 0xFF	; 255
     e20:	03 2e       	mov	r0, r19
     e22:	00 0c       	add	r0, r0
     e24:	44 0b       	sbc	r20, r20
     e26:	55 0b       	sbc	r21, r21
     e28:	6f ef       	ldi	r22, 0xFF	; 255
     e2a:	7f ef       	ldi	r23, 0xFF	; 255
     e2c:	8f ef       	ldi	r24, 0xFF	; 255
     e2e:	9f e3       	ldi	r25, 0x3F	; 63
     e30:	0e 94 1a 08 	call	0x1034	; 0x1034 <__divmodsi4>
     e34:	2e 87       	std	Y+14, r18	; 0x0e
     e36:	3f 87       	std	Y+15, r19	; 0x0f
     e38:	48 8b       	std	Y+16, r20	; 0x10
     e3a:	59 8b       	std	Y+17, r21	; 0x11
}
     e3c:	df 91       	pop	r29
     e3e:	cf 91       	pop	r28
     e40:	08 95       	ret

00000e42 <pid_Controller>:
 *  \param setPoint  Desired value.
 *  \param processValue  Measured value.
 *  \param pid_st  PID status struct.
 */
int16_t pid_Controller(int16_t setPoint, int16_t processValue, struct PID_DATA *pid_st)
{
     e42:	ef 92       	push	r14
     e44:	ff 92       	push	r15
     e46:	0f 93       	push	r16
     e48:	1f 93       	push	r17
     e4a:	cf 93       	push	r28
     e4c:	df 93       	push	r29
     e4e:	8b 01       	movw	r16, r22
     e50:	fa 01       	movw	r30, r20
  int16_t error, p_term, d_term;
  int32_t i_term, ret, temp;

  error = setPoint - processValue;
     e52:	9c 01       	movw	r18, r24
     e54:	26 1b       	sub	r18, r22
     e56:	37 0b       	sbc	r19, r23

  // Calculate Pterm and limit error overflow
  if (error > pid_st->maxError){
     e58:	84 85       	ldd	r24, Z+12	; 0x0c
     e5a:	95 85       	ldd	r25, Z+13	; 0x0d
     e5c:	82 17       	cp	r24, r18
     e5e:	93 07       	cpc	r25, r19
     e60:	84 f0       	brlt	.+32     	; 0xe82 <pid_Controller+0x40>
    p_term = MAX_INT;
  }
  else if (error < -pid_st->maxError){
     e62:	91 95       	neg	r25
     e64:	81 95       	neg	r24
     e66:	91 09       	sbc	r25, r1
     e68:	28 17       	cp	r18, r24
     e6a:	39 07       	cpc	r19, r25
     e6c:	6c f0       	brlt	.+26     	; 0xe88 <pid_Controller+0x46>
    p_term = -MAX_INT;
  }
  else{
    p_term = pid_st->P_Factor * error;
     e6e:	86 81       	ldd	r24, Z+6	; 0x06
     e70:	97 81       	ldd	r25, Z+7	; 0x07
     e72:	28 9f       	mul	r18, r24
     e74:	e0 01       	movw	r28, r0
     e76:	29 9f       	mul	r18, r25
     e78:	d0 0d       	add	r29, r0
     e7a:	38 9f       	mul	r19, r24
     e7c:	d0 0d       	add	r29, r0
     e7e:	11 24       	eor	r1, r1
     e80:	05 c0       	rjmp	.+10     	; 0xe8c <pid_Controller+0x4a>

  error = setPoint - processValue;

  // Calculate Pterm and limit error overflow
  if (error > pid_st->maxError){
    p_term = MAX_INT;
     e82:	cf ef       	ldi	r28, 0xFF	; 255
     e84:	df e7       	ldi	r29, 0x7F	; 127
     e86:	02 c0       	rjmp	.+4      	; 0xe8c <pid_Controller+0x4a>
  }
  else if (error < -pid_st->maxError){
    p_term = -MAX_INT;
     e88:	c1 e0       	ldi	r28, 0x01	; 1
     e8a:	d0 e8       	ldi	r29, 0x80	; 128
  else{
    p_term = pid_st->P_Factor * error;
  }

  // Calculate Iterm and limit integral runaway
  temp = pid_st->sumError + error;
     e8c:	c9 01       	movw	r24, r18
     e8e:	33 0f       	add	r19, r19
     e90:	aa 0b       	sbc	r26, r26
     e92:	bb 0b       	sbc	r27, r27
     e94:	42 81       	ldd	r20, Z+2	; 0x02
     e96:	53 81       	ldd	r21, Z+3	; 0x03
     e98:	64 81       	ldd	r22, Z+4	; 0x04
     e9a:	75 81       	ldd	r23, Z+5	; 0x05
     e9c:	9a 01       	movw	r18, r20
     e9e:	ab 01       	movw	r20, r22
     ea0:	28 0f       	add	r18, r24
     ea2:	39 1f       	adc	r19, r25
     ea4:	4a 1f       	adc	r20, r26
     ea6:	5b 1f       	adc	r21, r27
  if(temp > pid_st->maxSumError){
     ea8:	86 85       	ldd	r24, Z+14	; 0x0e
     eaa:	97 85       	ldd	r25, Z+15	; 0x0f
     eac:	a0 89       	ldd	r26, Z+16	; 0x10
     eae:	b1 89       	ldd	r27, Z+17	; 0x11
     eb0:	82 17       	cp	r24, r18
     eb2:	93 07       	cpc	r25, r19
     eb4:	a4 07       	cpc	r26, r20
     eb6:	b5 07       	cpc	r27, r21
     eb8:	4c f4       	brge	.+18     	; 0xecc <pid_Controller+0x8a>
    i_term = MAX_I_TERM;
    pid_st->sumError = pid_st->maxSumError;
     eba:	82 83       	std	Z+2, r24	; 0x02
     ebc:	93 83       	std	Z+3, r25	; 0x03
     ebe:	a4 83       	std	Z+4, r26	; 0x04
     ec0:	b5 83       	std	Z+5, r27	; 0x05
  }

  // Calculate Iterm and limit integral runaway
  temp = pid_st->sumError + error;
  if(temp > pid_st->maxSumError){
    i_term = MAX_I_TERM;
     ec2:	6f ef       	ldi	r22, 0xFF	; 255
     ec4:	7f ef       	ldi	r23, 0xFF	; 255
     ec6:	8f ef       	ldi	r24, 0xFF	; 255
     ec8:	9f e3       	ldi	r25, 0x3F	; 63
     eca:	1d c0       	rjmp	.+58     	; 0xf06 <pid_Controller+0xc4>
    pid_st->sumError = pid_st->maxSumError;
  }
  else if(temp < -pid_st->maxSumError){
     ecc:	b0 95       	com	r27
     ece:	a0 95       	com	r26
     ed0:	90 95       	com	r25
     ed2:	81 95       	neg	r24
     ed4:	9f 4f       	sbci	r25, 0xFF	; 255
     ed6:	af 4f       	sbci	r26, 0xFF	; 255
     ed8:	bf 4f       	sbci	r27, 0xFF	; 255
     eda:	28 17       	cp	r18, r24
     edc:	39 07       	cpc	r19, r25
     ede:	4a 07       	cpc	r20, r26
     ee0:	5b 07       	cpc	r21, r27
     ee2:	4c f4       	brge	.+18     	; 0xef6 <pid_Controller+0xb4>
    i_term = -MAX_I_TERM;
    pid_st->sumError = -pid_st->maxSumError;
     ee4:	82 83       	std	Z+2, r24	; 0x02
     ee6:	93 83       	std	Z+3, r25	; 0x03
     ee8:	a4 83       	std	Z+4, r26	; 0x04
     eea:	b5 83       	std	Z+5, r27	; 0x05
  if(temp > pid_st->maxSumError){
    i_term = MAX_I_TERM;
    pid_st->sumError = pid_st->maxSumError;
  }
  else if(temp < -pid_st->maxSumError){
    i_term = -MAX_I_TERM;
     eec:	61 e0       	ldi	r22, 0x01	; 1
     eee:	70 e0       	ldi	r23, 0x00	; 0
     ef0:	80 e0       	ldi	r24, 0x00	; 0
     ef2:	90 ec       	ldi	r25, 0xC0	; 192
     ef4:	08 c0       	rjmp	.+16     	; 0xf06 <pid_Controller+0xc4>
    pid_st->sumError = -pid_st->maxSumError;
  }
  else{
    pid_st->sumError = temp;
     ef6:	22 83       	std	Z+2, r18	; 0x02
     ef8:	33 83       	std	Z+3, r19	; 0x03
     efa:	44 83       	std	Z+4, r20	; 0x04
     efc:	55 83       	std	Z+5, r21	; 0x05
    i_term = pid_st->I_Factor * pid_st->sumError;
     efe:	a0 85       	ldd	r26, Z+8	; 0x08
     f00:	b1 85       	ldd	r27, Z+9	; 0x09
     f02:	0e 94 42 08 	call	0x1084	; 0x1084 <__mulshisi3>
  }

  // Calculate Dterm
  d_term = pid_st->D_Factor * (pid_st->lastProcessValue - processValue);
     f06:	20 81       	ld	r18, Z
     f08:	31 81       	ldd	r19, Z+1	; 0x01
     f0a:	20 1b       	sub	r18, r16
     f0c:	31 0b       	sbc	r19, r17
     f0e:	a2 85       	ldd	r26, Z+10	; 0x0a
     f10:	b3 85       	ldd	r27, Z+11	; 0x0b
     f12:	2a 9f       	mul	r18, r26
     f14:	70 01       	movw	r14, r0
     f16:	2b 9f       	mul	r18, r27
     f18:	f0 0c       	add	r15, r0
     f1a:	3a 9f       	mul	r19, r26
     f1c:	f0 0c       	add	r15, r0
     f1e:	11 24       	eor	r1, r1

  pid_st->lastProcessValue = processValue;
     f20:	11 83       	std	Z+1, r17	; 0x01
     f22:	00 83       	st	Z, r16

  ret = (p_term + i_term + d_term) / SCALING_FACTOR;
     f24:	8e 01       	movw	r16, r28
     f26:	dd 0f       	add	r29, r29
     f28:	22 0b       	sbc	r18, r18
     f2a:	33 0b       	sbc	r19, r19
     f2c:	ab 01       	movw	r20, r22
     f2e:	bc 01       	movw	r22, r24
     f30:	40 0f       	add	r20, r16
     f32:	51 1f       	adc	r21, r17
     f34:	62 1f       	adc	r22, r18
     f36:	73 1f       	adc	r23, r19
     f38:	c7 01       	movw	r24, r14
     f3a:	ff 0c       	add	r15, r15
     f3c:	aa 0b       	sbc	r26, r26
     f3e:	bb 0b       	sbc	r27, r27
     f40:	8a 01       	movw	r16, r20
     f42:	9b 01       	movw	r18, r22
     f44:	08 0f       	add	r16, r24
     f46:	19 1f       	adc	r17, r25
     f48:	2a 1f       	adc	r18, r26
     f4a:	3b 1f       	adc	r19, r27
     f4c:	c9 01       	movw	r24, r18
     f4e:	b8 01       	movw	r22, r16
     f50:	20 e8       	ldi	r18, 0x80	; 128
     f52:	30 e0       	ldi	r19, 0x00	; 0
     f54:	40 e0       	ldi	r20, 0x00	; 0
     f56:	50 e0       	ldi	r21, 0x00	; 0
     f58:	0e 94 1a 08 	call	0x1034	; 0x1034 <__divmodsi4>
  else if(ret < 0){
    ret = 0;
  }*/

  return((int16_t)ret);
}
     f5c:	c9 01       	movw	r24, r18
     f5e:	df 91       	pop	r29
     f60:	cf 91       	pop	r28
     f62:	1f 91       	pop	r17
     f64:	0f 91       	pop	r16
     f66:	ff 90       	pop	r15
     f68:	ef 90       	pop	r14
     f6a:	08 95       	ret

00000f6c <pid_Reset_Integrator>:
 *
 *  Calling this function will reset the integrator in the PID regulator.
 */
void pid_Reset_Integrator(pidData_t *pid_st)
{
  pid_st->sumError = 0;
     f6c:	fc 01       	movw	r30, r24
     f6e:	12 82       	std	Z+2, r1	; 0x02
     f70:	13 82       	std	Z+3, r1	; 0x03
     f72:	14 82       	std	Z+4, r1	; 0x04
     f74:	15 82       	std	Z+5, r1	; 0x05
     f76:	08 95       	ret

00000f78 <init_pwm_m>:
#include <util/delay.h>

void init_pwm_m(){
    short unsigned int valeur_init;	 // init des PWM à 0%

	PORTH |= (1<<M1)|(1<<M2)|(1<<M3);
     f78:	e2 e0       	ldi	r30, 0x02	; 2
     f7a:	f1 e0       	ldi	r31, 0x01	; 1
     f7c:	80 81       	ld	r24, Z
     f7e:	88 63       	ori	r24, 0x38	; 56
     f80:	80 83       	st	Z, r24
	PORTL |= (1<<M4)|(1<<M5)|(1<<M6);
     f82:	eb e0       	ldi	r30, 0x0B	; 11
     f84:	f1 e0       	ldi	r31, 0x01	; 1
     f86:	80 81       	ld	r24, Z
     f88:	88 63       	ori	r24, 0x38	; 56
     f8a:	80 83       	st	Z, r24

	//TIMER 4 :
	// Clear OC4A/B on Compare Match when up-counting. Set OC4A/B on Compare Match when down-counting.
	//Mode PWM phase correct (WGM)
	TCCR4A = (1<<COM4A1)|(1<<COM4B1)|(1<<COM4C1)|(2<<WGM40);
     f8c:	3a ea       	ldi	r19, 0xAA	; 170
     f8e:	30 93 a0 00 	sts	0x00A0, r19	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7e00a0>
	TCCR4B = (2<<WGM42)|(1<<CS41); // prediv : 8
     f92:	22 e1       	ldi	r18, 0x12	; 18
     f94:	20 93 a1 00 	sts	0x00A1, r18	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7e00a1>
	ICR4 = 10000;
     f98:	80 e1       	ldi	r24, 0x10	; 16
     f9a:	97 e2       	ldi	r25, 0x27	; 39
     f9c:	90 93 a7 00 	sts	0x00A7, r25	; 0x8000a7 <__TEXT_REGION_LENGTH__+0x7e00a7>
     fa0:	80 93 a6 00 	sts	0x00A6, r24	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7e00a6>

	// TIMER 5 :
	// PWM, Phase Correct avec TOP = 0xFF = 255
	TCCR5A = (1<<COM5A1)|(1<<COM5B1)|(1<<COM5C1)|(2<<WGM50);
     fa4:	30 93 20 01 	sts	0x0120, r19	; 0x800120 <__TEXT_REGION_LENGTH__+0x7e0120>
	TCCR5B = (2<<WGM52)|(1<<CS51); // prediv : 8
     fa8:	20 93 21 01 	sts	0x0121, r18	; 0x800121 <__TEXT_REGION_LENGTH__+0x7e0121>
	ICR5 = 10000;
     fac:	90 93 27 01 	sts	0x0127, r25	; 0x800127 <__TEXT_REGION_LENGTH__+0x7e0127>
     fb0:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <__TEXT_REGION_LENGTH__+0x7e0126>

	valeur_init = 1000;//Valeur max : 2000

	OCR4A = valeur_init; //M1
     fb4:	88 ee       	ldi	r24, 0xE8	; 232
     fb6:	93 e0       	ldi	r25, 0x03	; 3
     fb8:	90 93 a9 00 	sts	0x00A9, r25	; 0x8000a9 <__TEXT_REGION_LENGTH__+0x7e00a9>
     fbc:	80 93 a8 00 	sts	0x00A8, r24	; 0x8000a8 <__TEXT_REGION_LENGTH__+0x7e00a8>
	OCR4B = valeur_init; //M2
     fc0:	90 93 ab 00 	sts	0x00AB, r25	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7e00ab>
     fc4:	80 93 aa 00 	sts	0x00AA, r24	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7e00aa>
	OCR4C = valeur_init; //M3
     fc8:	90 93 ad 00 	sts	0x00AD, r25	; 0x8000ad <__TEXT_REGION_LENGTH__+0x7e00ad>
     fcc:	80 93 ac 00 	sts	0x00AC, r24	; 0x8000ac <__TEXT_REGION_LENGTH__+0x7e00ac>
	OCR5A = valeur_init; //M4
     fd0:	90 93 29 01 	sts	0x0129, r25	; 0x800129 <__TEXT_REGION_LENGTH__+0x7e0129>
     fd4:	80 93 28 01 	sts	0x0128, r24	; 0x800128 <__TEXT_REGION_LENGTH__+0x7e0128>
     fd8:	08 95       	ret

00000fda <init_timer1>:
}

void init_timer1(){
//Pour transformer en valeur numérique les valeurs de la PPM
	TCCR1A = 0; //mode normal
     fda:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
	TCCR1B = (2<<CS10); // prediv : 8
     fde:	82 e0       	ldi	r24, 0x02	; 2
     fe0:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
	TIFR1  = (1<<TOV1); // remise a 0 du flag
     fe4:	81 e0       	ldi	r24, 0x01	; 1
     fe6:	86 bb       	out	0x16, r24	; 22
	TIMSK1 = (1<<TOIE1); // génère une interruption sur overflow
     fe8:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__TEXT_REGION_LENGTH__+0x7e006f>
     fec:	08 95       	ret

00000fee <init_timer3>:
}


void init_timer3(){
//Ce timer sert à avoir un échantillonage précis et périodique de 20 ms
	TCCR3A = 0;
     fee:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x7e0090>
	TCCR3B = (1<<WGM32) | (2<<CS00); // mode CTC prediv : 8
     ff2:	8a e0       	ldi	r24, 0x0A	; 10
     ff4:	80 93 91 00 	sts	0x0091, r24	; 0x800091 <__TEXT_REGION_LENGTH__+0x7e0091>
	TIMSK3 = (1<<OCIE3A); //génère une interruption sur overflow
     ff8:	82 e0       	ldi	r24, 0x02	; 2
     ffa:	80 93 71 00 	sts	0x0071, r24	; 0x800071 <__TEXT_REGION_LENGTH__+0x7e0071>
	OCR3A  =  40000; //fréquence de 50Hz ( T = 20 ms )
     ffe:	80 e4       	ldi	r24, 0x40	; 64
    1000:	9c e9       	ldi	r25, 0x9C	; 156
    1002:	90 93 99 00 	sts	0x0099, r25	; 0x800099 <__TEXT_REGION_LENGTH__+0x7e0099>
    1006:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <__TEXT_REGION_LENGTH__+0x7e0098>
    100a:	08 95       	ret

0000100c <__divmodhi4>:
    100c:	97 fb       	bst	r25, 7
    100e:	07 2e       	mov	r0, r23
    1010:	16 f4       	brtc	.+4      	; 0x1016 <__divmodhi4+0xa>
    1012:	00 94       	com	r0
    1014:	07 d0       	rcall	.+14     	; 0x1024 <__divmodhi4_neg1>
    1016:	77 fd       	sbrc	r23, 7
    1018:	09 d0       	rcall	.+18     	; 0x102c <__divmodhi4_neg2>
    101a:	0e 94 4a 08 	call	0x1094	; 0x1094 <__udivmodhi4>
    101e:	07 fc       	sbrc	r0, 7
    1020:	05 d0       	rcall	.+10     	; 0x102c <__divmodhi4_neg2>
    1022:	3e f4       	brtc	.+14     	; 0x1032 <__divmodhi4_exit>

00001024 <__divmodhi4_neg1>:
    1024:	90 95       	com	r25
    1026:	81 95       	neg	r24
    1028:	9f 4f       	sbci	r25, 0xFF	; 255
    102a:	08 95       	ret

0000102c <__divmodhi4_neg2>:
    102c:	70 95       	com	r23
    102e:	61 95       	neg	r22
    1030:	7f 4f       	sbci	r23, 0xFF	; 255

00001032 <__divmodhi4_exit>:
    1032:	08 95       	ret

00001034 <__divmodsi4>:
    1034:	05 2e       	mov	r0, r21
    1036:	97 fb       	bst	r25, 7
    1038:	1e f4       	brtc	.+6      	; 0x1040 <__divmodsi4+0xc>
    103a:	00 94       	com	r0
    103c:	0e 94 31 08 	call	0x1062	; 0x1062 <__negsi2>
    1040:	57 fd       	sbrc	r21, 7
    1042:	07 d0       	rcall	.+14     	; 0x1052 <__divmodsi4_neg2>
    1044:	0e 94 5e 08 	call	0x10bc	; 0x10bc <__udivmodsi4>
    1048:	07 fc       	sbrc	r0, 7
    104a:	03 d0       	rcall	.+6      	; 0x1052 <__divmodsi4_neg2>
    104c:	4e f4       	brtc	.+18     	; 0x1060 <__divmodsi4_exit>
    104e:	0c 94 31 08 	jmp	0x1062	; 0x1062 <__negsi2>

00001052 <__divmodsi4_neg2>:
    1052:	50 95       	com	r21
    1054:	40 95       	com	r20
    1056:	30 95       	com	r19
    1058:	21 95       	neg	r18
    105a:	3f 4f       	sbci	r19, 0xFF	; 255
    105c:	4f 4f       	sbci	r20, 0xFF	; 255
    105e:	5f 4f       	sbci	r21, 0xFF	; 255

00001060 <__divmodsi4_exit>:
    1060:	08 95       	ret

00001062 <__negsi2>:
    1062:	90 95       	com	r25
    1064:	80 95       	com	r24
    1066:	70 95       	com	r23
    1068:	61 95       	neg	r22
    106a:	7f 4f       	sbci	r23, 0xFF	; 255
    106c:	8f 4f       	sbci	r24, 0xFF	; 255
    106e:	9f 4f       	sbci	r25, 0xFF	; 255
    1070:	08 95       	ret

00001072 <__tablejump2__>:
    1072:	ee 0f       	add	r30, r30
    1074:	ff 1f       	adc	r31, r31
    1076:	00 24       	eor	r0, r0
    1078:	00 1c       	adc	r0, r0
    107a:	0b be       	out	0x3b, r0	; 59
    107c:	07 90       	elpm	r0, Z+
    107e:	f6 91       	elpm	r31, Z
    1080:	e0 2d       	mov	r30, r0
    1082:	09 94       	ijmp

00001084 <__mulshisi3>:
    1084:	b7 ff       	sbrs	r27, 7
    1086:	0c 94 80 08 	jmp	0x1100	; 0x1100 <__muluhisi3>

0000108a <__mulohisi3>:
    108a:	0e 94 80 08 	call	0x1100	; 0x1100 <__muluhisi3>
    108e:	82 1b       	sub	r24, r18
    1090:	93 0b       	sbc	r25, r19
    1092:	08 95       	ret

00001094 <__udivmodhi4>:
    1094:	aa 1b       	sub	r26, r26
    1096:	bb 1b       	sub	r27, r27
    1098:	51 e1       	ldi	r21, 0x11	; 17
    109a:	07 c0       	rjmp	.+14     	; 0x10aa <__udivmodhi4_ep>

0000109c <__udivmodhi4_loop>:
    109c:	aa 1f       	adc	r26, r26
    109e:	bb 1f       	adc	r27, r27
    10a0:	a6 17       	cp	r26, r22
    10a2:	b7 07       	cpc	r27, r23
    10a4:	10 f0       	brcs	.+4      	; 0x10aa <__udivmodhi4_ep>
    10a6:	a6 1b       	sub	r26, r22
    10a8:	b7 0b       	sbc	r27, r23

000010aa <__udivmodhi4_ep>:
    10aa:	88 1f       	adc	r24, r24
    10ac:	99 1f       	adc	r25, r25
    10ae:	5a 95       	dec	r21
    10b0:	a9 f7       	brne	.-22     	; 0x109c <__udivmodhi4_loop>
    10b2:	80 95       	com	r24
    10b4:	90 95       	com	r25
    10b6:	bc 01       	movw	r22, r24
    10b8:	cd 01       	movw	r24, r26
    10ba:	08 95       	ret

000010bc <__udivmodsi4>:
    10bc:	a1 e2       	ldi	r26, 0x21	; 33
    10be:	1a 2e       	mov	r1, r26
    10c0:	aa 1b       	sub	r26, r26
    10c2:	bb 1b       	sub	r27, r27
    10c4:	fd 01       	movw	r30, r26
    10c6:	0d c0       	rjmp	.+26     	; 0x10e2 <__udivmodsi4_ep>

000010c8 <__udivmodsi4_loop>:
    10c8:	aa 1f       	adc	r26, r26
    10ca:	bb 1f       	adc	r27, r27
    10cc:	ee 1f       	adc	r30, r30
    10ce:	ff 1f       	adc	r31, r31
    10d0:	a2 17       	cp	r26, r18
    10d2:	b3 07       	cpc	r27, r19
    10d4:	e4 07       	cpc	r30, r20
    10d6:	f5 07       	cpc	r31, r21
    10d8:	20 f0       	brcs	.+8      	; 0x10e2 <__udivmodsi4_ep>
    10da:	a2 1b       	sub	r26, r18
    10dc:	b3 0b       	sbc	r27, r19
    10de:	e4 0b       	sbc	r30, r20
    10e0:	f5 0b       	sbc	r31, r21

000010e2 <__udivmodsi4_ep>:
    10e2:	66 1f       	adc	r22, r22
    10e4:	77 1f       	adc	r23, r23
    10e6:	88 1f       	adc	r24, r24
    10e8:	99 1f       	adc	r25, r25
    10ea:	1a 94       	dec	r1
    10ec:	69 f7       	brne	.-38     	; 0x10c8 <__udivmodsi4_loop>
    10ee:	60 95       	com	r22
    10f0:	70 95       	com	r23
    10f2:	80 95       	com	r24
    10f4:	90 95       	com	r25
    10f6:	9b 01       	movw	r18, r22
    10f8:	ac 01       	movw	r20, r24
    10fa:	bd 01       	movw	r22, r26
    10fc:	cf 01       	movw	r24, r30
    10fe:	08 95       	ret

00001100 <__muluhisi3>:
    1100:	0e 94 8b 08 	call	0x1116	; 0x1116 <__umulhisi3>
    1104:	a5 9f       	mul	r26, r21
    1106:	90 0d       	add	r25, r0
    1108:	b4 9f       	mul	r27, r20
    110a:	90 0d       	add	r25, r0
    110c:	a4 9f       	mul	r26, r20
    110e:	80 0d       	add	r24, r0
    1110:	91 1d       	adc	r25, r1
    1112:	11 24       	eor	r1, r1
    1114:	08 95       	ret

00001116 <__umulhisi3>:
    1116:	a2 9f       	mul	r26, r18
    1118:	b0 01       	movw	r22, r0
    111a:	b3 9f       	mul	r27, r19
    111c:	c0 01       	movw	r24, r0
    111e:	a3 9f       	mul	r26, r19
    1120:	70 0d       	add	r23, r0
    1122:	81 1d       	adc	r24, r1
    1124:	11 24       	eor	r1, r1
    1126:	91 1d       	adc	r25, r1
    1128:	b2 9f       	mul	r27, r18
    112a:	70 0d       	add	r23, r0
    112c:	81 1d       	adc	r24, r1
    112e:	11 24       	eor	r1, r1
    1130:	91 1d       	adc	r25, r1
    1132:	08 95       	ret

00001134 <__divsf3>:
    1134:	0e 94 ae 08 	call	0x115c	; 0x115c <__divsf3x>
    1138:	0c 94 96 09 	jmp	0x132c	; 0x132c <__fp_round>
    113c:	0e 94 8f 09 	call	0x131e	; 0x131e <__fp_pscB>
    1140:	58 f0       	brcs	.+22     	; 0x1158 <__divsf3+0x24>
    1142:	0e 94 88 09 	call	0x1310	; 0x1310 <__fp_pscA>
    1146:	40 f0       	brcs	.+16     	; 0x1158 <__divsf3+0x24>
    1148:	29 f4       	brne	.+10     	; 0x1154 <__divsf3+0x20>
    114a:	5f 3f       	cpi	r21, 0xFF	; 255
    114c:	29 f0       	breq	.+10     	; 0x1158 <__divsf3+0x24>
    114e:	0c 94 7f 09 	jmp	0x12fe	; 0x12fe <__fp_inf>
    1152:	51 11       	cpse	r21, r1
    1154:	0c 94 ca 09 	jmp	0x1394	; 0x1394 <__fp_szero>
    1158:	0c 94 85 09 	jmp	0x130a	; 0x130a <__fp_nan>

0000115c <__divsf3x>:
    115c:	0e 94 a7 09 	call	0x134e	; 0x134e <__fp_split3>
    1160:	68 f3       	brcs	.-38     	; 0x113c <__divsf3+0x8>

00001162 <__divsf3_pse>:
    1162:	99 23       	and	r25, r25
    1164:	b1 f3       	breq	.-20     	; 0x1152 <__divsf3+0x1e>
    1166:	55 23       	and	r21, r21
    1168:	91 f3       	breq	.-28     	; 0x114e <__divsf3+0x1a>
    116a:	95 1b       	sub	r25, r21
    116c:	55 0b       	sbc	r21, r21
    116e:	bb 27       	eor	r27, r27
    1170:	aa 27       	eor	r26, r26
    1172:	62 17       	cp	r22, r18
    1174:	73 07       	cpc	r23, r19
    1176:	84 07       	cpc	r24, r20
    1178:	38 f0       	brcs	.+14     	; 0x1188 <__divsf3_pse+0x26>
    117a:	9f 5f       	subi	r25, 0xFF	; 255
    117c:	5f 4f       	sbci	r21, 0xFF	; 255
    117e:	22 0f       	add	r18, r18
    1180:	33 1f       	adc	r19, r19
    1182:	44 1f       	adc	r20, r20
    1184:	aa 1f       	adc	r26, r26
    1186:	a9 f3       	breq	.-22     	; 0x1172 <__divsf3_pse+0x10>
    1188:	35 d0       	rcall	.+106    	; 0x11f4 <__divsf3_pse+0x92>
    118a:	0e 2e       	mov	r0, r30
    118c:	3a f0       	brmi	.+14     	; 0x119c <__divsf3_pse+0x3a>
    118e:	e0 e8       	ldi	r30, 0x80	; 128
    1190:	32 d0       	rcall	.+100    	; 0x11f6 <__divsf3_pse+0x94>
    1192:	91 50       	subi	r25, 0x01	; 1
    1194:	50 40       	sbci	r21, 0x00	; 0
    1196:	e6 95       	lsr	r30
    1198:	00 1c       	adc	r0, r0
    119a:	ca f7       	brpl	.-14     	; 0x118e <__divsf3_pse+0x2c>
    119c:	2b d0       	rcall	.+86     	; 0x11f4 <__divsf3_pse+0x92>
    119e:	fe 2f       	mov	r31, r30
    11a0:	29 d0       	rcall	.+82     	; 0x11f4 <__divsf3_pse+0x92>
    11a2:	66 0f       	add	r22, r22
    11a4:	77 1f       	adc	r23, r23
    11a6:	88 1f       	adc	r24, r24
    11a8:	bb 1f       	adc	r27, r27
    11aa:	26 17       	cp	r18, r22
    11ac:	37 07       	cpc	r19, r23
    11ae:	48 07       	cpc	r20, r24
    11b0:	ab 07       	cpc	r26, r27
    11b2:	b0 e8       	ldi	r27, 0x80	; 128
    11b4:	09 f0       	breq	.+2      	; 0x11b8 <__divsf3_pse+0x56>
    11b6:	bb 0b       	sbc	r27, r27
    11b8:	80 2d       	mov	r24, r0
    11ba:	bf 01       	movw	r22, r30
    11bc:	ff 27       	eor	r31, r31
    11be:	93 58       	subi	r25, 0x83	; 131
    11c0:	5f 4f       	sbci	r21, 0xFF	; 255
    11c2:	3a f0       	brmi	.+14     	; 0x11d2 <__divsf3_pse+0x70>
    11c4:	9e 3f       	cpi	r25, 0xFE	; 254
    11c6:	51 05       	cpc	r21, r1
    11c8:	78 f0       	brcs	.+30     	; 0x11e8 <__divsf3_pse+0x86>
    11ca:	0c 94 7f 09 	jmp	0x12fe	; 0x12fe <__fp_inf>
    11ce:	0c 94 ca 09 	jmp	0x1394	; 0x1394 <__fp_szero>
    11d2:	5f 3f       	cpi	r21, 0xFF	; 255
    11d4:	e4 f3       	brlt	.-8      	; 0x11ce <__divsf3_pse+0x6c>
    11d6:	98 3e       	cpi	r25, 0xE8	; 232
    11d8:	d4 f3       	brlt	.-12     	; 0x11ce <__divsf3_pse+0x6c>
    11da:	86 95       	lsr	r24
    11dc:	77 95       	ror	r23
    11de:	67 95       	ror	r22
    11e0:	b7 95       	ror	r27
    11e2:	f7 95       	ror	r31
    11e4:	9f 5f       	subi	r25, 0xFF	; 255
    11e6:	c9 f7       	brne	.-14     	; 0x11da <__divsf3_pse+0x78>
    11e8:	88 0f       	add	r24, r24
    11ea:	91 1d       	adc	r25, r1
    11ec:	96 95       	lsr	r25
    11ee:	87 95       	ror	r24
    11f0:	97 f9       	bld	r25, 7
    11f2:	08 95       	ret
    11f4:	e1 e0       	ldi	r30, 0x01	; 1
    11f6:	66 0f       	add	r22, r22
    11f8:	77 1f       	adc	r23, r23
    11fa:	88 1f       	adc	r24, r24
    11fc:	bb 1f       	adc	r27, r27
    11fe:	62 17       	cp	r22, r18
    1200:	73 07       	cpc	r23, r19
    1202:	84 07       	cpc	r24, r20
    1204:	ba 07       	cpc	r27, r26
    1206:	20 f0       	brcs	.+8      	; 0x1210 <__divsf3_pse+0xae>
    1208:	62 1b       	sub	r22, r18
    120a:	73 0b       	sbc	r23, r19
    120c:	84 0b       	sbc	r24, r20
    120e:	ba 0b       	sbc	r27, r26
    1210:	ee 1f       	adc	r30, r30
    1212:	88 f7       	brcc	.-30     	; 0x11f6 <__divsf3_pse+0x94>
    1214:	e0 95       	com	r30
    1216:	08 95       	ret

00001218 <__fixsfsi>:
    1218:	0e 94 13 09 	call	0x1226	; 0x1226 <__fixunssfsi>
    121c:	68 94       	set
    121e:	b1 11       	cpse	r27, r1
    1220:	0c 94 ca 09 	jmp	0x1394	; 0x1394 <__fp_szero>
    1224:	08 95       	ret

00001226 <__fixunssfsi>:
    1226:	0e 94 af 09 	call	0x135e	; 0x135e <__fp_splitA>
    122a:	88 f0       	brcs	.+34     	; 0x124e <__fixunssfsi+0x28>
    122c:	9f 57       	subi	r25, 0x7F	; 127
    122e:	98 f0       	brcs	.+38     	; 0x1256 <__fixunssfsi+0x30>
    1230:	b9 2f       	mov	r27, r25
    1232:	99 27       	eor	r25, r25
    1234:	b7 51       	subi	r27, 0x17	; 23
    1236:	b0 f0       	brcs	.+44     	; 0x1264 <__fixunssfsi+0x3e>
    1238:	e1 f0       	breq	.+56     	; 0x1272 <__fixunssfsi+0x4c>
    123a:	66 0f       	add	r22, r22
    123c:	77 1f       	adc	r23, r23
    123e:	88 1f       	adc	r24, r24
    1240:	99 1f       	adc	r25, r25
    1242:	1a f0       	brmi	.+6      	; 0x124a <__fixunssfsi+0x24>
    1244:	ba 95       	dec	r27
    1246:	c9 f7       	brne	.-14     	; 0x123a <__fixunssfsi+0x14>
    1248:	14 c0       	rjmp	.+40     	; 0x1272 <__fixunssfsi+0x4c>
    124a:	b1 30       	cpi	r27, 0x01	; 1
    124c:	91 f0       	breq	.+36     	; 0x1272 <__fixunssfsi+0x4c>
    124e:	0e 94 c9 09 	call	0x1392	; 0x1392 <__fp_zero>
    1252:	b1 e0       	ldi	r27, 0x01	; 1
    1254:	08 95       	ret
    1256:	0c 94 c9 09 	jmp	0x1392	; 0x1392 <__fp_zero>
    125a:	67 2f       	mov	r22, r23
    125c:	78 2f       	mov	r23, r24
    125e:	88 27       	eor	r24, r24
    1260:	b8 5f       	subi	r27, 0xF8	; 248
    1262:	39 f0       	breq	.+14     	; 0x1272 <__fixunssfsi+0x4c>
    1264:	b9 3f       	cpi	r27, 0xF9	; 249
    1266:	cc f3       	brlt	.-14     	; 0x125a <__fixunssfsi+0x34>
    1268:	86 95       	lsr	r24
    126a:	77 95       	ror	r23
    126c:	67 95       	ror	r22
    126e:	b3 95       	inc	r27
    1270:	d9 f7       	brne	.-10     	; 0x1268 <__fixunssfsi+0x42>
    1272:	3e f4       	brtc	.+14     	; 0x1282 <__fixunssfsi+0x5c>
    1274:	90 95       	com	r25
    1276:	80 95       	com	r24
    1278:	70 95       	com	r23
    127a:	61 95       	neg	r22
    127c:	7f 4f       	sbci	r23, 0xFF	; 255
    127e:	8f 4f       	sbci	r24, 0xFF	; 255
    1280:	9f 4f       	sbci	r25, 0xFF	; 255
    1282:	08 95       	ret

00001284 <__floatunsisf>:
    1284:	e8 94       	clt
    1286:	09 c0       	rjmp	.+18     	; 0x129a <__floatsisf+0x12>

00001288 <__floatsisf>:
    1288:	97 fb       	bst	r25, 7
    128a:	3e f4       	brtc	.+14     	; 0x129a <__floatsisf+0x12>
    128c:	90 95       	com	r25
    128e:	80 95       	com	r24
    1290:	70 95       	com	r23
    1292:	61 95       	neg	r22
    1294:	7f 4f       	sbci	r23, 0xFF	; 255
    1296:	8f 4f       	sbci	r24, 0xFF	; 255
    1298:	9f 4f       	sbci	r25, 0xFF	; 255
    129a:	99 23       	and	r25, r25
    129c:	a9 f0       	breq	.+42     	; 0x12c8 <__floatsisf+0x40>
    129e:	f9 2f       	mov	r31, r25
    12a0:	96 e9       	ldi	r25, 0x96	; 150
    12a2:	bb 27       	eor	r27, r27
    12a4:	93 95       	inc	r25
    12a6:	f6 95       	lsr	r31
    12a8:	87 95       	ror	r24
    12aa:	77 95       	ror	r23
    12ac:	67 95       	ror	r22
    12ae:	b7 95       	ror	r27
    12b0:	f1 11       	cpse	r31, r1
    12b2:	f8 cf       	rjmp	.-16     	; 0x12a4 <__floatsisf+0x1c>
    12b4:	fa f4       	brpl	.+62     	; 0x12f4 <__floatsisf+0x6c>
    12b6:	bb 0f       	add	r27, r27
    12b8:	11 f4       	brne	.+4      	; 0x12be <__floatsisf+0x36>
    12ba:	60 ff       	sbrs	r22, 0
    12bc:	1b c0       	rjmp	.+54     	; 0x12f4 <__floatsisf+0x6c>
    12be:	6f 5f       	subi	r22, 0xFF	; 255
    12c0:	7f 4f       	sbci	r23, 0xFF	; 255
    12c2:	8f 4f       	sbci	r24, 0xFF	; 255
    12c4:	9f 4f       	sbci	r25, 0xFF	; 255
    12c6:	16 c0       	rjmp	.+44     	; 0x12f4 <__floatsisf+0x6c>
    12c8:	88 23       	and	r24, r24
    12ca:	11 f0       	breq	.+4      	; 0x12d0 <__floatsisf+0x48>
    12cc:	96 e9       	ldi	r25, 0x96	; 150
    12ce:	11 c0       	rjmp	.+34     	; 0x12f2 <__floatsisf+0x6a>
    12d0:	77 23       	and	r23, r23
    12d2:	21 f0       	breq	.+8      	; 0x12dc <__floatsisf+0x54>
    12d4:	9e e8       	ldi	r25, 0x8E	; 142
    12d6:	87 2f       	mov	r24, r23
    12d8:	76 2f       	mov	r23, r22
    12da:	05 c0       	rjmp	.+10     	; 0x12e6 <__floatsisf+0x5e>
    12dc:	66 23       	and	r22, r22
    12de:	71 f0       	breq	.+28     	; 0x12fc <__floatsisf+0x74>
    12e0:	96 e8       	ldi	r25, 0x86	; 134
    12e2:	86 2f       	mov	r24, r22
    12e4:	70 e0       	ldi	r23, 0x00	; 0
    12e6:	60 e0       	ldi	r22, 0x00	; 0
    12e8:	2a f0       	brmi	.+10     	; 0x12f4 <__floatsisf+0x6c>
    12ea:	9a 95       	dec	r25
    12ec:	66 0f       	add	r22, r22
    12ee:	77 1f       	adc	r23, r23
    12f0:	88 1f       	adc	r24, r24
    12f2:	da f7       	brpl	.-10     	; 0x12ea <__floatsisf+0x62>
    12f4:	88 0f       	add	r24, r24
    12f6:	96 95       	lsr	r25
    12f8:	87 95       	ror	r24
    12fa:	97 f9       	bld	r25, 7
    12fc:	08 95       	ret

000012fe <__fp_inf>:
    12fe:	97 f9       	bld	r25, 7
    1300:	9f 67       	ori	r25, 0x7F	; 127
    1302:	80 e8       	ldi	r24, 0x80	; 128
    1304:	70 e0       	ldi	r23, 0x00	; 0
    1306:	60 e0       	ldi	r22, 0x00	; 0
    1308:	08 95       	ret

0000130a <__fp_nan>:
    130a:	9f ef       	ldi	r25, 0xFF	; 255
    130c:	80 ec       	ldi	r24, 0xC0	; 192
    130e:	08 95       	ret

00001310 <__fp_pscA>:
    1310:	00 24       	eor	r0, r0
    1312:	0a 94       	dec	r0
    1314:	16 16       	cp	r1, r22
    1316:	17 06       	cpc	r1, r23
    1318:	18 06       	cpc	r1, r24
    131a:	09 06       	cpc	r0, r25
    131c:	08 95       	ret

0000131e <__fp_pscB>:
    131e:	00 24       	eor	r0, r0
    1320:	0a 94       	dec	r0
    1322:	12 16       	cp	r1, r18
    1324:	13 06       	cpc	r1, r19
    1326:	14 06       	cpc	r1, r20
    1328:	05 06       	cpc	r0, r21
    132a:	08 95       	ret

0000132c <__fp_round>:
    132c:	09 2e       	mov	r0, r25
    132e:	03 94       	inc	r0
    1330:	00 0c       	add	r0, r0
    1332:	11 f4       	brne	.+4      	; 0x1338 <__fp_round+0xc>
    1334:	88 23       	and	r24, r24
    1336:	52 f0       	brmi	.+20     	; 0x134c <__fp_round+0x20>
    1338:	bb 0f       	add	r27, r27
    133a:	40 f4       	brcc	.+16     	; 0x134c <__fp_round+0x20>
    133c:	bf 2b       	or	r27, r31
    133e:	11 f4       	brne	.+4      	; 0x1344 <__fp_round+0x18>
    1340:	60 ff       	sbrs	r22, 0
    1342:	04 c0       	rjmp	.+8      	; 0x134c <__fp_round+0x20>
    1344:	6f 5f       	subi	r22, 0xFF	; 255
    1346:	7f 4f       	sbci	r23, 0xFF	; 255
    1348:	8f 4f       	sbci	r24, 0xFF	; 255
    134a:	9f 4f       	sbci	r25, 0xFF	; 255
    134c:	08 95       	ret

0000134e <__fp_split3>:
    134e:	57 fd       	sbrc	r21, 7
    1350:	90 58       	subi	r25, 0x80	; 128
    1352:	44 0f       	add	r20, r20
    1354:	55 1f       	adc	r21, r21
    1356:	59 f0       	breq	.+22     	; 0x136e <__fp_splitA+0x10>
    1358:	5f 3f       	cpi	r21, 0xFF	; 255
    135a:	71 f0       	breq	.+28     	; 0x1378 <__fp_splitA+0x1a>
    135c:	47 95       	ror	r20

0000135e <__fp_splitA>:
    135e:	88 0f       	add	r24, r24
    1360:	97 fb       	bst	r25, 7
    1362:	99 1f       	adc	r25, r25
    1364:	61 f0       	breq	.+24     	; 0x137e <__fp_splitA+0x20>
    1366:	9f 3f       	cpi	r25, 0xFF	; 255
    1368:	79 f0       	breq	.+30     	; 0x1388 <__fp_splitA+0x2a>
    136a:	87 95       	ror	r24
    136c:	08 95       	ret
    136e:	12 16       	cp	r1, r18
    1370:	13 06       	cpc	r1, r19
    1372:	14 06       	cpc	r1, r20
    1374:	55 1f       	adc	r21, r21
    1376:	f2 cf       	rjmp	.-28     	; 0x135c <__fp_split3+0xe>
    1378:	46 95       	lsr	r20
    137a:	f1 df       	rcall	.-30     	; 0x135e <__fp_splitA>
    137c:	08 c0       	rjmp	.+16     	; 0x138e <__fp_splitA+0x30>
    137e:	16 16       	cp	r1, r22
    1380:	17 06       	cpc	r1, r23
    1382:	18 06       	cpc	r1, r24
    1384:	99 1f       	adc	r25, r25
    1386:	f1 cf       	rjmp	.-30     	; 0x136a <__fp_splitA+0xc>
    1388:	86 95       	lsr	r24
    138a:	71 05       	cpc	r23, r1
    138c:	61 05       	cpc	r22, r1
    138e:	08 94       	sec
    1390:	08 95       	ret

00001392 <__fp_zero>:
    1392:	e8 94       	clt

00001394 <__fp_szero>:
    1394:	bb 27       	eor	r27, r27
    1396:	66 27       	eor	r22, r22
    1398:	77 27       	eor	r23, r23
    139a:	cb 01       	movw	r24, r22
    139c:	97 f9       	bld	r25, 7
    139e:	08 95       	ret

000013a0 <_exit>:
    13a0:	f8 94       	cli

000013a2 <__stop_program>:
    13a2:	ff cf       	rjmp	.-2      	; 0x13a2 <__stop_program>
